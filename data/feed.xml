<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Web前端 腾讯AlloyTeam  Blog &#124; 愿景: 成为地球卓越的Web团队！</title>
	<atom:link href="http://www.alloyteam.com/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.alloyteam.com</link>
	<description>腾讯全端 AlloyTeam 团队 Blog</description>
	<lastBuildDate>Tue, 15 Sep 2015 09:04:49 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=4.3.1</generator>
	<item>
		<title>JavaScript数据结构和算法简述——数组</title>
		<link>http://www.alloyteam.com/2015/09/brief-javascript-data-structures-and-algorithms-the-array/</link>
		<comments>http://www.alloyteam.com/2015/09/brief-javascript-data-structures-and-algorithms-the-array/#comments</comments>
		<pubDate>Tue, 15 Sep 2015 08:54:49 +0000</pubDate>
		<dc:creator><![CDATA[TAT.李强]]></dc:creator>
				<category><![CDATA[JavaScript]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=8247</guid>
		<description><![CDATA[为什么先讲数组 数据结构可以简单的被分为线性结构和非线性结构。 线性结构大致包括： 数组（连续存储）； 链表（ [&#8230;]]]></description>
				<content:encoded><![CDATA[<h1>为什么先讲数组</h1>
<hr/>
<p>数据结构可以简单的被分为线性结构和非线性结构。</p>
<p>线性结构大致包括：</p>
<ol>
<li>数组（连续存储）；</li>
<li>链表（离散存储）；</li>
<li>栈（线性结构常见应用，由链表或数组增删和改进功能实现）；</li>
<li>队列（线性结构常见应用，由链表或数组增删和改进功能实现）；</li>
</ol>
<p>非线性结构大致包括：</p>
<ol>
<li>树；</li>
<li>图；</li>
</ol>
<p>其中，数组是应用最广泛的数据存储结构。它被植入到大部分编程语言中。由于数组十分容易懂，所以它被用来作为介绍数据结构的起点非常合适。</p>
<p><span id="more-8247"></span></p>
<h1>JavaScript数组基础知识</h1>
<hr/>
<p>在ECMAScript中数组是非常常用的引用类型了。ECMAScript所定义的数组和其他语言中的数组有着很大的区别。那么首先要说的就是数组在js中是一种特殊的对象。</p>
<p>特点：</p>
<ol>
<li>数组是一组数据的线性集合；</li>
<li>js数组更加类似java中的容器。长度可变，元素类型也可以不同；</li>
<li>数组的长度可以随时修改（length属性）；</li>
</ol>
<p>常用操作方法：</p>
<ul>
<li>push、pop</li>
<li>shift、unshift</li>
<li>splice、slice</li>
<li>concat、join、sort、reverse等</li>
</ul>
<h1>JavaScript数组操作</h1>
<hr/>
<p><strong>一、 数组方法：</strong></p>
<p><strong><em>1、 数组的创建</em></strong></p>
<p></p><pre class="crayon-plain-tag">var array = [];

var array = new Array();　//创建一个数组

var array = new Array([size]);　//创建一个数组并指定长度，注意不是上限，是长度

var array = new Array([element0[, element1[, ...[, elementN]]]]);　//创建一个数组并赋值</pre><p></p>
<p>注意：虽然第三种方法创建数组指定了长度，但实际上所有情况下数组都是变长的，也就是说即使指定了长度为5，仍然可以将元素存储在规定长度以外的，并且这时长度会随之改变。</p>
<p><strong><em>2、 数组元素的访问</em></strong></p>
<p></p><pre class="crayon-plain-tag">var getArrItem=array[1]; //获取数组的元素值

array[1]= &quot;new value&quot;; //给数组元素赋予新的值</pre><p></p>
<p><strong><em>3、 数组元素的添加</em></strong></p>
<p></p><pre class="crayon-plain-tag">array. push([item1 [item2 [. . . [itemN ]]]]);// 将一个或多个新元素添加到数组结尾，并返回数组新长度

array.unshift([item1 [item2 [. . . [itemN ]]]]);// 将一个或多个新元素添加到数组开始，数组中的元素自动后移，返回数组新长度

array.splice(insertPos,0,[item1[, item2[, . . . [,itemN]]]]);//将一个或多个新元素插入到数组的指定位置，插入位置的元素自动后移，返回&quot;&quot;。</pre><p></p>
<p><strong><em>4、 数组元素的删除</em></strong></p>
<p></p><pre class="crayon-plain-tag">array.pop(); //移除最后一个元素并返回该元素值

array.shift(); //移除最前一个元素并返回该元素值，数组中元素自动前移

array.splice(deletePos,deleteCount); //删除从指定位置deletePos开始的指定数量deleteCount的元素，数组形式返回所移除的元素

array.slice(start, [end]); //以数组的形式返回数组的一部分，注意不包括 end 对应的元素，如果省略 end 将复制 start 之后的所有元素</pre><p></p>
<p><strong><em>5、 数组的合并</em></strong></p>
<p></p><pre class="crayon-plain-tag">array.concat([item1[, item2[, . . . [,itemN]]]]); //将多个数组（也可以是字符串，或者是数组和字符串的混合）连接为一个数组，返回连接好的新的数组</pre><p></p>
<p><strong><em>6、 数组的拷贝</em></strong></p>
<p></p><pre class="crayon-plain-tag">array.slice(0); //返回数组的拷贝数组，注意是一个新的数组，不是指向

array.concat(); //返回数组的拷贝数组，注意是一个新的数组，不是指向</pre><p></p>
<p><strong><em>7、 数组元素的排序</em></strong></p>
<p></p><pre class="crayon-plain-tag">array.reverse(); //反转元素（最前的排到最后、最后的排到最前），返回数组地址

array.sort(); //对数组元素排序，返回数组地址</pre><p></p>
<p><strong><em>8、 数组元素的字符串化</em></strong></p>
<p></p><pre class="crayon-plain-tag">array.join(separator); //返回字符串，这个字符串将数组的每一个元素值连接在一起，中间用 separator 隔开。

toLocaleString 、toString 、valueOf：可以看作是join的特殊用法，不常用</pre><p></p>
<p>简单介绍了下数组各个方法的使用，也算是对js数组学习的一个review和总结，利用这些方法可以实现数组更复杂些的操作，具体大家可以自己去实践。可见，js数组的功能很强大。</p>
<p><strong>二、 数组属性</strong></p>
<p><strong><em>1、 length属性</em></strong></p>
<p>length属性表示数组的长度，即其中元素的个数。因为数组的索引总是由0开始，所以一个数组的上下限分别是：0和length-1。和其他大多数语言不同的是，JavaScript数组的length属性是可变的，这一点需要特别注意。当length属性被设置得更大时，整个数组的状态事实上不会发生变化，仅仅是length属性变大；当length属性被设置得比原来小时，则原先数组中索引大于或等于length的元素的值全部被丢失。下面是演示改变length属性的例子：</p>
<p></p><pre class="crayon-plain-tag">var arr=[12,23,5,3,25,98,76,54,56,76];

//定义了一个包含10个数字的数组

print(arr.length); //显示数组的长度10

arr.length=12; //增大数组的长度

print(arr.length); //显示数组的长度已经变为12

print(arr[8]); //显示第9个元素的值，为56

arr.length=5; //将数组的长度减少到5，索引等于或超过5的元素被丢弃

print(arr[8]); //显示第9个元素已经变为&quot;undefined&quot;

arr.length=10; //将数组长度恢复为10

print(arr[8]); //虽然长度被恢复为10，但第9个元素却无法收回，显示&quot;undefined&quot;</pre><p></p>
<p>由上面的代码我们可以清楚的看到length属性的性质。但length对象不仅可以显式的设置，它也有可能被隐式修改。JavaScript中可以使用一个未声明过的变量，同样，也可以使用一个未定义的数组元素（指索引超过或等于length的元素），这时，length属性的值将被设置为所使用元素索引的值加1。例如下面的代码：</p>
<p></p><pre class="crayon-plain-tag">var arr=[12,23,5,3,25,98,76,54,56,76];

print(arr.length); // 10

arr[15]=34;

print(arr.length); // 16</pre><p></p>
<p>代码中同样是先定义了一个包含10个数字的数组，可以看出其长度为10。随后使用了索引为15的元素，将其赋值为15，即 arr[15]=34，这时再输出数组的长度，得到的是16。无论如何，对于习惯于强类型编程的开发人员来说，这是一个很令人惊讶的特性。事实上，使用new Array()形式创建的数组，其初始长度就是为0，正是对其中未定义元素的操作，才使数组的长度发生变化。</p>
<p>综上，利用length属性可以方便的增加或者减少数组的容量。</p>
<p><strong><em>2、 prototype属性</em></strong></p>
<p>返回对象类型原型的引用。prototype 属性是 object 共有的。</p>
<p>objectName.prototype</p>
<p>objectName 参数是object对象的名称。</p>
<p>对于数组对象，以下例子说明 prototype 属性的用途。</p>
<p>给数组对象添加返回数组中最大元素值的方法。要完成这一点，声明一个函数，将它加入 Array.prototype， 并使用它。</p>
<p></p><pre class="crayon-plain-tag">function array_max() {

    var i,

    max = this[0];

    for (i = 1; i &lt; this.length; i++) {

        if (max &lt; this[i])

        max = this[i];

    }

    return max;

}

Array.prototype.max = array_max;

var x = new Array(1, 2, 3, 4, 5, 6);

print(x.max()); // 6</pre><p></p>
<p><strong><em>3、 constructor属性</em></strong></p>
<p>表示创建对象的函数。</p>
<p>object.constructor // object是对象或函数的名称。</p>
<p>说明：constructor 属性是所有具有 prototype 的对象的成员。constructor 属性保存了对构造特定对象实例的函数的引用。</p>
<p></p><pre class="crayon-plain-tag">x = new Array();

print(x.constructor === Array); // true</pre><p></p>
<h1>JavaScript数组算法的C语言实现</h1>
<hr/>
<p>使用没有指针的语言，个人觉得无法将数据结构和算法的精髓讲的出来，而且js底层已将数组相关算法封装好，所以这里不使用原生的js或者java等，而是使用c语言来实现。为了照顾没有学过指针的同学，我会尽可能的简单实现，并写好注释，画好图解，大家可以体会一下。</p>
<p></p><pre class="crayon-plain-tag"># include &lt;stdio.h&gt;
# include &lt;malloc.h&gt;  //包含了malloc函数
# include &lt;stdlib.h&gt;  //包含了exit函数

//定义了一个数据类型，该数据类型的名字叫做struct Arr, 该数据类型含有三个成员，分别是pBase, len, cnt
struct Arr
{
    int * pBase; //存储的是数组第一个元素的地址
    int len; //数组所能容纳的最大元素的个数
    int cnt; //当前数组有效元素的个数
};

void init_arr(struct Arr *, int);  //初始化数组
bool is_empty(struct Arr *); // 数组是否为空 
bool is_full(struct Arr *); // 数组是否已满 
bool push(struct Arr *, int); //追加元素 
void sort(struct Arr *); // 排序 
void reverse(struct Arr *); // 逆序 
bool insert(struct Arr *, int, int); // 插入元素 
bool del(struct Arr *, int, int *); // 删除元素 
void show_arr(struct Arr *); // 打印数组 

int main(void) {
    struct Arr arr;

    int val; // 存储删除元素 

    init_arr(&amp;arr, 6); // 初始化数组 
    show_arr(&amp;arr);

    push(&amp;arr, 4); // 在尾部追加元素 
    push(&amp;arr, 1);
    push(&amp;arr, -1);
    push(&amp;arr, 10);
    push(&amp;arr, 0);
    push(&amp;arr, 6);
    show_arr(&amp;arr);

    sort(&amp;arr); // 排序 
    show_arr(&amp;arr); 

    reverse(&amp;arr); // 逆序 
    show_arr(&amp;arr);

    del(&amp;arr, 4, &amp;val); // 删除指定位置元素 
    printf(&quot;您删除的元素是: %d\n&quot;, val);
    show_arr(&amp;arr);

    insert(&amp;arr, 4, 20); // 在指定位置插入元素 
    show_arr(&amp;arr);

    return 0;
}

void init_arr(struct Arr * pArr, int length) {
    pArr-&gt;pBase = (int *)malloc(sizeof(int) * length);
    if(NULL == pArr-&gt;pBase) {
        printf(&quot;动态内存分配失败!\n&quot;);
        exit(-1); //终止整个程序
    }
    else {
        pArr-&gt;len = length;
        pArr-&gt;cnt = 0;
    }
    return;
}

bool is_empty(struct Arr * pArr) {
    if(0 == pArr-&gt;cnt) {
        return true;
    } else {
        return false;   
    }       
}

bool is_full(struct Arr * pArr) {
    if (pArr-&gt;cnt == pArr-&gt;len) {
        return true;
    } else {
        return false;
    }
}

void show_arr(struct Arr * pArr) {
    if(is_empty(pArr)) {
        printf(&quot;数组为空!\n&quot;);
    } else {
        for(int i=0; i&lt;pArr-&gt;cnt; ++i) {
            printf(&quot;%d  &quot;, pArr-&gt;pBase[i]);
        }
        printf(&quot;\n&quot;);
    }
}

bool push(struct Arr * pArr, int val) {
    //满了就返回false
    if(is_full(pArr)) {
        return false;
    }
    //不满时追加
    pArr-&gt;pBase[pArr-&gt;cnt] = val; 
    (pArr-&gt;cnt)++;
    return true;
}

void sort(struct Arr * pArr) {
    int i, j, t;
    // 简单的冒泡排序法实现，后面的章节会单独讲排序算法 
    for(i=0; i&lt;pArr-&gt;cnt; ++i) {
        for(j=i+1; j&lt;pArr-&gt;cnt; ++j) {
            if(pArr-&gt;pBase[i] &gt; pArr-&gt;pBase[j]) {
                t = pArr-&gt;pBase[i];
                pArr-&gt;pBase[i] = pArr-&gt;pBase[j];
                pArr-&gt;pBase[j] = t;
            }
        }
    }
}

void reverse(struct Arr * pArr) {
    int i = 0;
    int j = pArr-&gt;cnt-1;
    int t;
    // 当i&lt;j时，置换i和j位置的元素 
    while(i &lt; j) {
        t = pArr-&gt;pBase[i];
        pArr-&gt;pBase[i] = pArr-&gt;pBase[j];
        pArr-&gt;pBase[j] = t;
        ++i;
        --j;
    }
    return;
}

bool insert(struct Arr * pArr, int pos, int val) {
    int i;
    // 满了就算了 
    if(is_full(pArr)) {
        return false;
    }
    // 如果插入的位置不在数组有效范围内就算了 
    if(pos&lt;1 || pos&gt;pArr-&gt;cnt+1) {
        return false;
    }
    // 从插入位置开始后移各元素，将插入位置空出 
    for(i=pArr-&gt;cnt-1; i&gt;=pos-1; --i) {
        pArr-&gt;pBase[i+1] = pArr-&gt;pBase[i];
    }
    // 给插入位置的元素赋值 
    pArr-&gt;pBase[pos-1] = val;
    //数组有效长度自增 
    (pArr-&gt;cnt)++;
    return true;
}

bool del(struct Arr * pArr, int pos, int * pVal) {
    int i;
    // 空就算了 
    if(is_empty(pArr)) {
        return false;
    }
    // 不在有效范围内就算了 
    if (pos&lt;1 || pos&gt;pArr-&gt;cnt) {
        return false;
    }
    // 存储被删除元素 
    *pVal = pArr-&gt;pBase[pos-1];
    // 从删除位置开始，前移各元素，将删除位置堵死 
    for (i=pos; i&lt;pArr-&gt;cnt; ++i) {
        pArr-&gt;pBase[i-1] = pArr-&gt;pBase[i];
    }
    // 数组有效长度自减 
    pArr-&gt;cnt--;
    return true;
}</pre><p></p>
<p><strong>执行结果：</strong></p>
<p><img src="http://i.imgur.com/Ty4dTF4.png" /></p>
<p><strong>程序图解：</strong></p>
<p><img src="http://i.imgur.com/xta5aTM.gif" /></p>
<h1>衡量算法的标准</h1>
<hr/>
<p>需要详细了解的同学请阅读相关书籍。这里我简单介绍一下。</p>
<p><strong><em>1、 时间复杂度</em></strong></p>
<p>程序大概要执行的次数，而非执行的时间</p>
<p>通常使用大O表示法（含义：&quot;order of&quot;大约是）来表示。比如无序数组的插入，无论数组中有多少数据项，都只需要在下一个有空的地方进行一步插入操作，那么可以说向一个无序数组中插入一个数据项的时间T是一个常数K： T=K；又比如线性查找，查找特定数据项所需的比较次数平均为数据项总数的一半，因此可以说：T=K<em>N/2，为了得到更加简洁的公式，可以将2并入K，可以得到：T=K</em>N。大O表示法同上面的公式比较类似，但是它省略了常数K。当比较算法时，并不在乎具体的处理器或者编译器，真正需要比较的是对应不同的N值T是怎样变化的，而不是具体的数字。</p>
<p><strong>用大O表示法表示数组相关算法运行时间：</strong></p>
<table style='width:100%;text-align:center;' border='1'>
<tr>
<th style="text-align: center;" width='20%'>算法</th>
<th style="text-align: center;" width='80%'>大O表示法</th>
</tr>
<tr>
<td>线性查找</td>
<td>O(N)</td>
</tr>
<tr>
<td>二分查找</td>
<td>O(logN)</td>
</tr>
<tr>
<td>无序数组的插入</td>
<td>O(1)</td>
</tr>
<tr>
<td>有序数组的插入</td>
<td>O(N)</td>
</tr>
<tr>
<td>无序数组的删除</td>
<td>O(N)</td>
</tr>
<tr>
<td>有序数组的删除</td>
<td>O(N)</td>
</tr>
</table>
<p>注：O(1)是优秀；O(logN)是良好；O(N)还可以；O(N<sup>2</sup>)就差一些了。</p>
<p><strong><em>2、 空间复杂度</em></strong></p>
<p>算法执行过程中大概所占用的最大内存</p>
<p><strong><em>3、 难易程度</em></strong></p>
<p>写出来的算法不能只让自己看得懂，或者自己写完以后自己也看不懂了。。。</p>
<p><strong><em>4、 健壮性</em></strong></p>
<p>不能一用就崩溃。。。</p>
<h1>为什么不用数组表示一切</h1>
<hr/>
<p>仅用数组看似可以完成所有的工作，那么为什么不用它来进行所有的数据存储呢？</p>
<p>在一个无序数组中可以很快进行插入（O(1)），但是查找却要花费较多的时间O(N)。在一个有序数组中可以查找的很快（O(logN)），但是插入却要O(N)。对于有序和无序数组，由于平均半数的数据项需要移动，所以删除操作平均需要花费O(N)。</p>
<p>如果有一种数据结构进行任何插入、删除和查找操作都很快（O(1)或者O(logN)）,那就太爽了哈。后面我们会向这一目标靠近。</p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/09/brief-javascript-data-structures-and-algorithms-the-array/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>初探 performance &#8211; 监控网页与程序性能</title>
		<link>http://www.alloyteam.com/2015/09/explore-performance/</link>
		<comments>http://www.alloyteam.com/2015/09/explore-performance/#comments</comments>
		<pubDate>Thu, 03 Sep 2015 07:26:47 +0000</pubDate>
		<dc:creator><![CDATA[TAT.felix]]></dc:creator>
				<category><![CDATA[JavaScript]]></category>
		<category><![CDATA[Web 前端优化]]></category>
		<category><![CDATA[Web开发]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=8233</guid>
		<description><![CDATA[使用 window.performance 提供了一组精确的数据，经过简单的计算就能得出一些网页性能数据。 配 [&#8230;]]]></description>
				<content:encoded><![CDATA[<h1>
	使用 window.performance 提供了一组精确的数据，经过简单的计算就能得出一些网页性能数据。<br />
</h1>
<p>
	配合上报一些客户端浏览器的设备类型等数据，就可以实现简单的统计啦！
</p>
<p>
	额，先看下兼容性如何：<a href="http://caniuse.com/#feat=nav-timing">http://caniuse.com/#feat=nav-timing</a>
</p>
<p>
	这篇文章中 Demo 的运行环境为最新的 Chrome 的控制台，如果你用的是其他浏览器，自查兼容性哈~
</p>
<p><span id="more-8233"></span></p>
<p>
	先来看看在 Chrome 浏览器控制台中执行&nbsp;window.performance&nbsp;会出现什么：
</p>
<p>
	<img alt="" src="http://cdn.alloyteam.com/wp-content/uploads/auto_save_image/2015/09/072454pGM.jpg" />
</p>
<h1>
	简单解释下 performance 中的属性：<br />
</h1>
<p>
	先看下一个请求发出的整个过程中，各种环节的时间顺序：
</p>
<p>
	<img alt="" src="http://cdn.alloyteam.com/wp-content/uploads/auto_save_image/2015/09/072455NuJ.png" />
</p>
<p></p><pre class="crayon-plain-tag">// 获取 performance 数据
var performance = {  
    // memory 是非标准属性，只在 Chrome 有
    // 财富问题：我有多少内存
    memory: {
        usedJSHeapSize:  16100000, // JS 对象（包括V8引擎内部对象）占用的内存，一定小于 totalJSHeapSize
        totalJSHeapSize: 35100000, // 可使用的内存
        jsHeapSizeLimit: 793000000 // 内存大小限制
    },

    //  哲学问题：我从哪里来？
    navigation: {
        redirectCount: 0, // 如果有重定向的话，页面通过几次重定向跳转而来
        type: 0           // 0   即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等）
                          // 1   即 TYPE_RELOAD       通过 window.location.reload() 刷新的页面
                          // 2   即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录）
                          // 255 即 TYPE_UNDEFINED    非以上方式进入的页面
    },

    timing: {
        // 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等
        navigationStart: 1441112691935,

        // 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0
        unloadEventStart: 0,

        // 和 unloadEventStart 相对应，返回前一个网页 unload 事件绑定的回调函数执行完毕的时间戳
        unloadEventEnd: 0,

        // 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0 
        redirectStart: 0,

        // 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0 
        redirectEnd: 0,

        // 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前
        fetchStart: 1441112692155,

        // DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等
        domainLookupStart: 1441112692155,

        // DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等
        domainLookupEnd: 1441112692155,

        // HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等
        // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间
        connectStart: 1441112692155,

        // HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等
        // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间
        // 注意这里握手结束，包括安全连接建立完成、SOCKS 授权通过
        connectEnd: 1441112692155,

        // HTTPS 连接开始的时间，如果不是安全连接，则值为 0
        secureConnectionStart: 0,

        // HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存
        // 连接错误重连时，这里显示的也是新建立连接的时间
        requestStart: 1441112692158,

        // HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存
        responseStart: 1441112692686,

        // HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存
        responseEnd: 1441112692687,

        // 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件
        domLoading: 1441112692690,

        // 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件
        // 注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源
        domInteractive: 1441112693093,

        // DOM 解析完成后，网页内资源加载开始的时间
        // 在 DOMContentLoaded 事件抛出前发生
        domContentLoadedEventStart: 1441112693093,

        // DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）
        domContentLoadedEventEnd: 1441112693101,

        // DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件
        domComplete: 1441112693214,

        // load 事件发送给文档，也即 load 回调函数开始执行的时间
        // 注意如果没有绑定 load 事件，值为 0
        loadEventStart: 1441112693214,

        // load 事件的回调函数执行完毕的时间
        loadEventEnd: 1441112693215

        // 字母顺序
        // connectEnd: 1441112692155,
        // connectStart: 1441112692155,
        // domComplete: 1441112693214,
        // domContentLoadedEventEnd: 1441112693101,
        // domContentLoadedEventStart: 1441112693093,
        // domInteractive: 1441112693093,
        // domLoading: 1441112692690,
        // domainLookupEnd: 1441112692155,
        // domainLookupStart: 1441112692155,
        // fetchStart: 1441112692155,
        // loadEventEnd: 1441112693215,
        // loadEventStart: 1441112693214,
        // navigationStart: 1441112691935,
        // redirectEnd: 0,
        // redirectStart: 0,
        // requestStart: 1441112692158,
        // responseEnd: 1441112692687,
        // responseStart: 1441112692686,
        // secureConnectionStart: 0,
        // unloadEventEnd: 0,
        // unloadEventStart: 0
    }
};</pre><p></p>
<p>
	具体的含义都在注释里说明了，接下来我们看下能用这些数据做什么？
</p>
<h1>
	使用 performance.timing 信息简单计算出网页性能数据<br />
</h1>
<p>
	在注释中，我用【重要】标注了我个人认为比较有用的数据，用【原因】标注了为啥要重点关注这个数据
</p>
<p></p><pre class="crayon-plain-tag">// 计算加载时间
function getPerformanceTiming () {  
    var performance = window.performance;

    if (!performance) {
        // 当前浏览器不支持
        console.log(&#39;你的浏览器不支持 performance 接口&#39;);
        return;
    }

    var t = performance.timing;
    var times = {};

    //【重要】页面加载完成的时间
    //【原因】这几乎代表了用户等待页面可用的时间
    times.loadPage = t.loadEventEnd - t.navigationStart;

    //【重要】解析 DOM 树结构的时间
    //【原因】反省下你的 DOM 树嵌套是不是太多了！
    times.domReady = t.domComplete - t.responseEnd;

    //【重要】重定向的时间
    //【原因】拒绝重定向！比如，http://example.com/ 就不该写成 http://example.com
    times.redirect = t.redirectEnd - t.redirectStart;

    //【重要】DNS 查询时间
    //【原因】DNS 预加载做了么？页面内是不是使用了太多不同的域名导致域名查询的时间太长？
    // 可使用 HTML5 Prefetch 预查询 DNS ，见：[HTML5 prefetch](http://segmentfault.com/a/1190000000633364)            
    times.lookupDomain = t.domainLookupEnd - t.domainLookupStart;

    //【重要】读取页面第一个字节的时间
    //【原因】这可以理解为用户拿到你的资源占用的时间，加异地机房了么，加CDN 处理了么？加带宽了么？加 CPU 运算速度了么？
    // TTFB 即 Time To First Byte 的意思
    // 维基百科：https://en.wikipedia.org/wiki/Time_To_First_Byte
    times.ttfb = t.responseStart - t.navigationStart;

    //【重要】内容加载完成的时间
    //【原因】页面内容经过 gzip 压缩了么，静态资源 css/js 等压缩了么？
    times.request = t.responseEnd - t.requestStart;

    //【重要】执行 onload 回调函数的时间
    //【原因】是否太多不必要的操作都放到 onload 回调函数里执行了，考虑过延迟加载、按需加载的策略么？
    times.loadEvent = t.loadEventEnd - t.loadEventStart;

    // DNS 缓存时间
    times.appcache = t.domainLookupStart - t.fetchStart;

    // 卸载页面的时间
    times.unloadEvent = t.unloadEventEnd - t.unloadEventStart;

    // TCP 建立连接完成握手的时间
    times.connect = t.connectEnd - t.connectStart;

    return times;
}</pre><p></p>
<h1>
	使用performance.getEntries() 获取所有资源请求的时间数据<br />
</h1>
<p>
	这个函数返回的将是一个数组，包含了页面中所有的 HTTP 请求，这里拿第一个请求&nbsp;window.performance.getEntries()[0]&nbsp;举例。 注意 HTTP 请求有可能命中本地缓存，所以请求响应的间隔将非常短 可以看到，与 performance.timing 对比： 没有与 DOM 相关的属性：
</p>
<ul>
<li>
<p>
			navigationStart
		</p>
</li>
<li>
<p>
			unloadEventStart
		</p>
</li>
<li>
<p>
			unloadEventEnd
		</p>
</li>
<li>
<p>
			domLoading
		</p>
</li>
<li>
<p>
			domInteractive
		</p>
</li>
<li>
<p>
			domContentLoadedEventStart
		</p>
</li>
<li>
<p>
			domContentLoadedEventEnd
		</p>
</li>
<li>
<p>
			domComplete
		</p>
</li>
<li>
<p>
			loadEventStart
		</p>
</li>
<li>
<p>
			loadEventEnd
		</p>
</li>
</ul>
<p>
	新增属性：
</p>
<ul>
<li>
<p>
			name
		</p>
</li>
<li>
<p>
			entryType
		</p>
</li>
<li>
<p>
			initiatorType
		</p>
</li>
<li>
<p>
			duration
		</p>
</li>
</ul>
<p>
	与 window.performance.timing 中包含的属性就不再介绍了：
</p>
<p></p><pre class="crayon-plain-tag">var entry = {  
    // 资源名称，也是资源的绝对路径
    name: &quot;http://cdn.alloyteam.com/wp-content/themes/alloyteam/style.css&quot;,
    // 资源类型
    entryType: &quot;resource&quot;,
    // 谁发起的请求
    initiatorType: &quot;link&quot;, // link 即 &lt;link&gt; 标签
                           // script 即 &lt;script&gt;
                           // redirect 即重定向
    // 加载时间
    duration: 18.13399999809917,

    redirectStart: 0,
    redirectEnd: 0,

    fetchStart: 424.57699999795295,

    domainLookupStart: 0,
    domainLookupEnd: 0,

    connectStart: 0,
    connectEnd: 0,

    secureConnectionStart: 0,

    requestStart: 0,

    responseStart: 0,
    responseEnd: 442.7109999960521,

    startTime: 424.57699999795295
};</pre><p></p>
<p>
	可以像&nbsp;getPerformanceTiming&nbsp;获取网页的时间一样，获取某个资源的时间：
</p>
<p></p><pre class="crayon-plain-tag">// 计算加载时间
function getEntryTiming (entry) {  
    var t = entry;
    var times = {};

    // 重定向的时间
    times.redirect = t.redirectEnd - t.redirectStart;

    // DNS 查询时间
    times.lookupDomain = t.domainLookupEnd - t.domainLookupStart;

    // 内容加载完成的时间
    times.request = t.responseEnd - t.requestStart;

    // TCP 建立连接完成握手的时间
    times.connect = t.connectEnd - t.connectStart;

    // 挂载 entry 返回
    times.name = entry.name;
    times.entryType = entry.entryType;
    times.initiatorType = entry.initiatorType;
    times.duration = entry.duration;

    return times;
}

// test
// var entries = window.performance.getEntries();
// entries.forEach(function (entry) {
//     var times = getEntryTiming(entry);
//     console.log(times);
// });</pre><p></p>
<h1>
	使用 performance.now() 精确计算程序执行时间<br />
</h1>
<p>
	performance.now()&nbsp;与&nbsp;Date.now()&nbsp;不同的是，返回了以微秒（百万分之一秒）为单位的时间，更加精准。
</p>
<p>
	并且与&nbsp;Date.now()&nbsp;会受系统程序执行阻塞的影响不同，performance.now()&nbsp;的时间是以恒定速率递增的，不受系统时间的影响（系统时间可被人为或软件调整）。
</p>
<p>
	注意&nbsp;Date.now()&nbsp;输出的是 UNIX 时间，即距离 1970 的时间，而&nbsp;performance.now()&nbsp;输出的是相对于&nbsp;performance.timing.navigationStart(页面初始化) 的时间。
</p>
<p>
	使用&nbsp;Date.now()&nbsp;的差值并非绝对精确，因为计算时间时受系统限制（可能阻塞）。但使用&nbsp;performance.now()&nbsp;的差值，并不影响我们计算程序执行的精确时间。
</p>
<p></p><pre class="crayon-plain-tag">// 计算程序执行的精确时间
function getFunctionTimeWithDate (func) {  
    var timeStart = Data.now();

    // 执行开始
    func();
    // 执行结束
    var timeEnd = Data.now();

    // 返回执行时间
    return (timeEnd - timeStart);
}
function getFunctionTimeWithPerformance (func) {  
    var timeStart = window.performance.now();

    // 执行开始
    func();
    // 执行结束
    var timeEnd = window.performance.now();

    // 返回执行时间
    return (timeEnd - timeStart);
}</pre><p></p>
<h1>
	使用 performance.mark() 也可以精确计算程序执行时间<br />
</h1>
<p>
	使用&nbsp;performance.mark()&nbsp;标记各种时间戳（就像在地图上打点），保存为各种测量值（测量地图上的点之间的距离），便可以批量地分析这些数据了。
</p>
<p>
	直接上示例代码看注释便明白：
</p>
<p></p><pre class="crayon-plain-tag">function randomFunc (n) {  
    if (!n) {
        // 生成一个随机数
        n = ~~(Math.random() * 10000);
    }
    var nameStart = &#39;markStart&#39; + n; 
    var nameEnd   = &#39;markEnd&#39; + n; 
    // 函数执行前做个标记
    window.performance.mark(nameStart);

    for (var i = 0; i &lt; n; i++) {
        // do nothing
    }

    // 函数执行后再做个标记
    window.performance.mark(nameEnd);

    // 然后测量这个两个标记间的时间距离，并保存起来
    var name = &#39;measureRandomFunc&#39; + n;
    window.performance.measure(name, nameStart, nameEnd);
}

// 执行三次看看
randomFunc();  
randomFunc();  
// 指定一个名字
randomFunc(888);</pre><p></p>
<p></p><pre class="crayon-plain-tag">// 看下保存起来的标记 mark
var marks = window.performance.getEntriesByType(&#39;mark&#39;);  
console.log(marks);</pre><p></p>
<p>
	<img alt="" src="http://cdn.alloyteam.com/wp-content/uploads/auto_save_image/2015/09/072504WLm.jpg" />
</p>
<p></p><pre class="crayon-plain-tag">// 看下保存起来的测量 measure
var measure = window.performance.getEntriesByType(&#39;measure&#39;);  
console.log(measure);</pre><p></p>
<p>
	<img alt="" src="http://cdn.alloyteam.com/wp-content/uploads/auto_save_image/2015/09/072509yhq.jpg" />
</p>
<p></p><pre class="crayon-plain-tag">// 看下我们自定义的测量
var entries = window.performance.getEntriesByName(&#39;measureRandomFunc888&#39;);  
console.log(entries);</pre><p></p>
<p>
	<img alt="" src="http://cdn.alloyteam.com/wp-content/uploads/auto_save_image/2015/09/072511gsM.jpg" />
</p>
<p>
	可以看到，for&nbsp;循环&nbsp;measureRandomFunc888&nbsp;的时候
</p>
<p>
	结束时间为: 4875.1199999969685
</p>
<p>
	开始时间为：4875.112999987323
</p>
<p>
	执行时间为：4875.1199999969685 &#8211; 4875.112999987323 = 0.00700000964
</p>
<p>
	标记和测量用完了可以清除掉：
</p>
<p></p><pre class="crayon-plain-tag">// 清除指定标记
window.performance.clearMarks(&#39;markStart888&#39;);  
// 清除所有标记
window.performance.clearMarks();

// 清除指定测量
window.performance.clearMeasures(&#39;measureRandomFunc&#39;);  
// 清除所有测量
window.performance.clearMeasures();</pre><p></p>
<p>
	当然&nbsp;performance.mark()&nbsp;只是提供了一些简便的测量方式，比如之前我们测量 domReady 是这么测的：
</p>
<p></p><pre class="crayon-plain-tag">// 计算 domReady 时间
var t = performance.timing  
var domReadyTime = t.domComplete - t.responseEnd;  
console.log(domReadyTime)</pre><p></p>
<p>
	其实就可以写成：
</p>
<p></p><pre class="crayon-plain-tag">window.performance.measure(&#39;domReady&#39;,&#39;responseEnd&#39; , &#39;domComplete&#39;);  
var domReadyMeasure = window.performance.getEntriesByName(&#39;domReady&#39;);  
console.log(domReadyMeasure);</pre><p></p>
<p>
	<img alt="" src="http://cdn.alloyteam.com/wp-content/uploads/auto_save_image/2015/09/072513gda.jpg" />
</p>
<h1>
	抛砖引玉：performance 数据能干啥用？<br />
</h1>
<p>
	熟悉 Chrome 开发者工具的朋友应该知道：在开发环境下，其实我们自己打开 Chrome 的开发者工具，切换到网络面板，就能很详细的看到网页性能相关的数据。但当我们需要统计分析用户打开我们网页时的性能如何时，我们将 performance 原始信息或通过简单计算后的信息(如上面写到的&nbsp;getPerformanceTiming()&nbsp;和&nbsp;getEntryTiming()) 上传到服务器，配合其他信息（如 HTTP 请求头信息），就完美啦~</p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/09/explore-performance/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>AngularJs依赖注入的研究</title>
		<link>http://www.alloyteam.com/2015/09/angularjs-study-of-dependency-injection/</link>
		<comments>http://www.alloyteam.com/2015/09/angularjs-study-of-dependency-injection/#comments</comments>
		<pubDate>Tue, 01 Sep 2015 02:20:18 +0000</pubDate>
		<dc:creator><![CDATA[TAT.tennylv]]></dc:creator>
				<category><![CDATA[Web开发]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=8219</guid>
		<description><![CDATA[什么是依赖注入呢，我的理解，简单点就是说我的东西我自己并不像来拿着，我想要我依赖的那个人来帮我拿着，当我需要的 [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>
	什么是依赖注入呢，我的理解，简单点就是说我的东西我自己并不像来拿着，我想要我依赖的那个人来帮我拿着，当我需要的时候，他给我就行了。当然这只是简单的理解，还是用代码解释比较清楚一些。
</p>
<p>
	这里有一个function，很简单。
</p>
<p></p><pre class="crayon-plain-tag">var a = function(name){
console.log(name);
}</pre><p></p>
<p>
	<span id="more-8219"></span>我们调用它：
</p>
<p></p><pre class="crayon-plain-tag">a(&#39;abc&#39;)；//abc</pre><p></p>
<p>
	<span style="font-size:16px">那么，就像我上面说的，我能不能自己不传参数呢，例如：</span>
</p>
<p></p><pre class="crayon-plain-tag">a();//undefined</pre><p></p>
<p>
	如何才能实现让别人帮我们注入这个参数呢：
</p>
<p></p><pre class="crayon-plain-tag">var inject = function(name,callback){
  return function(){
     callback(name);
  }
}</pre><p></p>
<p>
	像这样，我们在定义参数的时候这样传：
</p>
<p></p><pre class="crayon-plain-tag">a = inject(&#39;abc&#39;,a)</pre><p></p>
<p>
	我们再调用a方法：
</p>
<p></p><pre class="crayon-plain-tag">a()；//abc</pre><p></p>
<p>
	这其实就是最简单的依赖注入了，当然这么简单是不行的，其实这是很无意义的，下面我们来看一下高深的angularjs：
</p>
<p>
	&nbsp;
</p>
<p></p><pre class="crayon-plain-tag">var MyController = function($scope){
        $scope.test = 1;
}</pre><p></p>
<p>
	上面这段代码定义了angularjs的controller里面用到了scope，这样还看不出问题，在看下面：
</p>
<p></p><pre class="crayon-plain-tag">var MyController = function($scope,$http){
        $scope.test = 1;
        $http.get(&#39;&#39;);
}</pre><p></p>
<p>
	上面这段代码在原来的基础上增加了http,那么问题就来了，angular在调用controller的时候怎么知道我需要scope还是http还是两个都需要呢，这就牵着到了angular里的依赖注入，那么我们来模拟一下。
</p>
<p>
	假设没有angular的情况下，我们：
</p>
<p></p><pre class="crayon-plain-tag">var MyController = function($scope,$http){
        $scope.test = 1;
        $http.get(&#39;&#39;);
}
MyController();//undefined</pre><p></p>
<p>
	肯定会报错的，然后我们来修改下我们的inject：
</p>
<p></p><pre class="crayon-plain-tag">var inject = {
            dependencies: {},
            register: function(key, value) {
                this.dependencies[key] = value;
            },
            resolve: function(deps, func, scope) {
                var arr = [];
                for (var i = 0 ; i &lt; deps.length ; i++) {
                    if (this.dependencies.hasOwnProperty(deps[i])) {
                       arr.push(this.dependencies[deps[i]])
                    }
                }
                console.log(arr);
                return function(){
                    func.apply(scope || {}, arr);
                }

            }
        }</pre><p></p>
<p>
	这里解释一下，我们用了dependencies来存储所有的依赖，register来实现注册依赖，resolve方法来实现注入。
</p>
<p>
	然后我们模仿angular来预先注册几个模块：
</p>
<p></p><pre class="crayon-plain-tag">inject.register(&#39;$http&#39;, {&#39;get&#39;:function(){console.log(&#39;get&#39;)}});
inject.register(&#39;$scope&#39;, {&#39;test&#39;:&#39;&#39;});
inject.register(&#39;$location&#39;, {&#39;hash&#39;:function(){console.log(&#39;hash&#39;)}});</pre><p></p>
<p>
	然后我们就可以注入了：
</p>
<p></p><pre class="crayon-plain-tag">MyController = inject.resolve(['$http','$scope'],MyController)；
MyController();</pre><p></p>
<p>
	我们只需要http和scope，所以我们只传了两个，虽然这样看似解决了依赖注入，但是还有很多问题，比如我要交换两个参数的位置就不行了。
</p>
<p>
	于是翻看了angularjs的源码，找到了：
</p>
<p></p><pre class="crayon-plain-tag">var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;

    .....
    function annotate(fn) {
      .....
      fnText = fn.toString().replace(STRIP_COMMENTS, &#39;&#39;);
      argDecl = fnText.match(FN_ARGS);
      .....
    }</pre><p></p>
<p>
	我们忽略掉一些细节代码，只看我们需要的。annotate方法和我们的resolve方法很像。它转换传递过去的func为字符串，删除掉注释代码，然后抽取其中的参数。让我们看下它的执行结果，修改一下resolve方法：
</p>
<p></p><pre class="crayon-plain-tag">resolve: function(deps, func, scope) {

                var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
                var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
                var fnText = func.toString().replace(STRIP_COMMENTS, &#39;&#39;);
                var argDecl = fnText.match(FN_ARGS);
                console.log(argDecl);


            }</pre><p></p>
<p>
	打印出argDecl：
</p>
<p></p><pre class="crayon-plain-tag">["function ($scope,$http)", "$scope,$http", index: 0, input: "function ($scope,$http){&crarr;                $scope.test = 1;&crarr;                $http.get('');&crarr;        }"]</pre><p></p>
<p>
	可以看到，这个数组拿到了func的参数，argDecl［1］ = &ldquo;$scope,$http&rdquo;;
</p>
<p>
	根据这个，我们来修改resolve：
</p>
<p></p><pre class="crayon-plain-tag">resolve: function(func, scope) {

                var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
                var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
                var fnText = func.toString().replace(STRIP_COMMENTS, &#39;&#39;);
                var argDecl = fnText.match(FN_ARGS);
                console.log(argDecl);
                var deps = argDecl[1].split(&#39;,&#39;);
                var arr = [];
                for (var i = 0 ; i &lt; deps.length ; i++) {
                    if (this.dependencies.hasOwnProperty(deps[i])) {
                       arr.push(this.dependencies[deps[i]])
                    }
                }
                return function(){
                    func.apply(scope || {}, arr);
                }

            }</pre><p></p>
<p>
	OK，这次我们不用在意参数的顺序了，但是angular远比我们要想的多，大多数情况下，我们的js都是要压缩的，所以function的实参会被替换，如果是那样的话，我们这个方法的argDecl［1］ = &ldquo;$scope,$http&rdquo;;就会是argDecl［1］ = &ldquo;r,t&rdquo;;类似这样的变量，那么又该怎么解决呢？
</p>
<p>
	angular官方有这样的解释：
</p>
<p>
	为了克服压缩引起的问题，只要在控制器函数里面给$inject属性赋值一个依赖服务标识符的数组，就像：
</p>
<p></p><pre class="crayon-plain-tag">var MyController = ['$scope', '$http', function($scope, $http) {  }];</pre><p></p>
<p>
	那么，用到我们这个方法里面又该怎么实现呢？那我们在看看angular的源码吧：
</p>
<p></p><pre class="crayon-plain-tag">....
} else if (isArray(fn)) {
    last = fn.length - 1;
    assertArgFn(fn[last], &#39;fn&#39;)
    $inject = fn.slice(0, last);
  } else {
....</pre><p></p>
<p>
	看到了吧，之所以用到数组也是有原因的，把需要的依赖写在方法的前面，于是，应用到我们的reslove方法：
</p>
<p></p><pre class="crayon-plain-tag">resolve: function(func, scope) {
                if (isArray(func)) {
                    var last = func.length - 1;
                    var deps = func.slice(0, last);
                    func = func[last]
                } else {
                    var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
                    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
                    var fnText = func.toString().replace(STRIP_COMMENTS, &#39;&#39;);
                    var argDecl = fnText.match(FN_ARGS);
                    var deps = argDecl[1].split(&#39;,&#39;);
                }

                var arr = [];
                for (var i = 0 ; i &lt; deps.length ; i++) {
                    if (this.dependencies.hasOwnProperty(deps[i])) {
                       arr.push(this.dependencies[deps[i]])
                    }
                }
                return function(){
                    func.apply(scope || {}, arr);
                }

            }</pre><p></p>
<p>
	OK，到这里，便可以用我们的inject来模拟angular的依赖注入了，当然，真正angular的依赖注入还有很多东西，这里就不在详细描述了。
</p>
<p>
	以上观点都是我的个人见解，如有错误欢迎指正！
</p>
<p>
	&nbsp;
</p>
<p>
	<span style="font-size:18px">参考资料：<a href="http://www.nihaoshijie.com.cn/index.php/archives/306">关于anjularjs双向绑定的研究</a></span></p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/09/angularjs-study-of-dependency-injection/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>是时候使用ES 2015了</title>
		<link>http://www.alloyteam.com/2015/08/its-time-to-use-es2015/</link>
		<comments>http://www.alloyteam.com/2015/08/its-time-to-use-es2015/#comments</comments>
		<pubDate>Mon, 31 Aug 2015 15:50:59 +0000</pubDate>
		<dc:creator><![CDATA[TAT.云中飞扬]]></dc:creator>
				<category><![CDATA[JavaScript]]></category>
		<category><![CDATA[Web开发]]></category>
		<category><![CDATA[移动开发]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=8216</guid>
		<description><![CDATA[在Web中使用ES 2015 想要在浏览器端使用ES 2015最新语法，其实很简单，只需要一个转换器即可，Ba [&#8230;]]]></description>
				<content:encoded><![CDATA[<h1>
	在Web中使用ES 2015<br />
</h1>
<p>
	想要在浏览器端使用ES 2015最新语法，其实很简单，只需要一个转换器即可，<a href="https://babeljs.io/">Babel</a>是ES 2015最流行的转换器之一，Babel加上各种插件和polyfill能基本上支持绝大部分新语法。
</p>
<p>
	在你的构建中，插入一步使用Babel将ES 2015的代码转换成完全兼容ES5的代码的任务，你甚至都不必了解Babel的具体用法，就可以爽爽的开始写ES 2015代码了。
</p>
<p>
	使用gulp-babel在需要的地方转换一下即可。
</p>
<p>
	&nbsp;
</p>
<p>
	<span id="more-8216"></span>
</p>
<p></p><pre class="crayon-plain-tag">var gulp = require(&#39;gulp&#39;);
var babel = require(&#39;gulp-babel&#39;);

gulp.task(&#39;babel&#39;, function () {
    return gulp.src(&#39;src/js/*.js&#39;)
        .pipe(babel())
        .pipe(gulp.dest(&#39;dist&#39;));
});</pre><p></p>
<p>
	笔者在实际生产中已使用到一些ES 2015新特性，通过Babel转换成完全兼容ES5的语法，然后发布到正式环境，大大提高了开发体验。下面将一部分使用的较多，能改善编码体验的点列出来，当然也有一些坑，希望读者能尽早熟悉尽早投入ES 2015的怀抱。
</p>
<h3>
	最基本的：let和const<br />
</h3>
<p></p><pre class="crayon-plain-tag">let a = 1;
const A = 2;</pre><p></p>
<p>
	转换成
</p>
<p></p><pre class="crayon-plain-tag">var a = 1;
var A = 2;</pre><p></p>
<p>
	Babel只是单纯将let和const转换成了var，并没有真正实现块作用域和常量的功能，也没有消除变量提升的问题，这样避免了引入一些额外的代码，而且也已经完全与ES5兼容了。
</p>
<h3>
	模板字符串<br />
</h3>
<p></p><pre class="crayon-plain-tag">const name = &#39;Jarvis&#39;;
const template = `My name is ${name}`;</pre><p></p>
<p>
	转换成
</p>
<p></p><pre class="crayon-plain-tag">var name = &#39;Jarvis&#39;;
var template = &#39;My name is &#39; + name;</pre><p></p>
<p>
	模板字符串（两个反丿号）是ES 2015的一个重要的新功能，允许模板字符串里面通过${variable}的方式直接嵌变量，可以替代老旧的字符串拼接方法，而且里面可以任意使用单双引号。
</p>
<p>
	这个改进很实用，现在就可以用起来了，再也不用担心单双引号谁该写在谁的外面了。
</p>
<p>
	模板字符串还直接支持多行文本，如：
</p>
<p></p><pre class="crayon-plain-tag">const tmpl = `text line 1,
    text line 2,
    textline 3`;</pre><p></p>
<p>
	在拼接html的时候特别有用。
</p>
<h3>
	箭头函数<br />
</h3>
<p>
	箭头函数语法：
</p>
<p></p><pre class="crayon-plain-tag">const fn = () =&gt; {
    console.log(&#39;hello world&#39;);
};</pre><p></p>
<p>
	转换成
</p>
<p></p><pre class="crayon-plain-tag">var fn = function() {
    console.log(&#39;hello world&#39;);
};</pre><p></p>
<p>
	箭头函数通常比匿名函数还要简洁，几乎可以取代所有使用function的地方，不过用起来别太嗨了，下面有这个坑还是值得注意。
</p>
<p>
	箭头函数最大的特点在于this关键字在声明或者定义箭头函数的时候就已经被绑定好了，而且不会改变，这个特性用来解决setTimeout等一些异步函数this会改变的问题很爽，但下面这个却是个大问题：
</p>
<p></p><pre class="crayon-plain-tag">$(&#39;#selector&#39;).on(&#39;tap&#39;, () =&gt; {
    $(this).addClass(&#39;new&#39;);
});</pre><p></p>
<p>
	将会转换成
</p>
<p></p><pre class="crayon-plain-tag">var _this = this;
$(&#39;#selector&#39;).on(&#39;tap&#39;, function() {
    $(_this).addClass(&#39;new&#39;);
});</pre><p></p>
<p>
	看出问题了吧，相当于箭头函数是在事件监听器外面就先定义好了，这时候的this指向的全局变量，并非我们期望中的那个dom元素。
</p>
<p>
	这时候就不适合用箭头函数了，除非你明确知道this指向的谁或者根本用不上this。
</p>
<h3>
	&#8230;args<br />
</h3>
<p>
	我在前面的文章介绍过V8新的<a href="http://www.alloyteam.com/2015/06/strong-mode-jie-shao/">Strong Mode</a>已经不允许使用arguments关键字了，取而代之是&#8230;args。
</p>
<p></p><pre class="crayon-plain-tag">function (...args) {
    console.log(args);
}</pre><p></p>
<p>
	这里的args是个真正的数组了，使用到arguments的地方推荐都换成&#8230;args吧，还能避免一些意想不到的坑，比如下面这个。
</p>
<p>
	箭头函数里面是获取不到argunents变量的，如果你这样写
</p>
<p></p><pre class="crayon-plain-tag">const fn = () =&gt; {
    console.log(arguments);
};</pre><p></p>
<p>
	将被转换成
</p>
<p></p><pre class="crayon-plain-tag">var _arguments = arguments;
var fn = function() {
    console.log(_arguments);
};</pre><p></p>
<p>
	这时候的arguments映射的是外层函数的arguments，如果使用&#8230;args就不会有这个问题。
</p>
<h3>
	默认参数<br />
</h3>
<p>
	默认函数参数我想用处非常大了，从此再也不用写一大堆参数判断的代码了。
</p>
<p></p><pre class="crayon-plain-tag">function fn(params = {}, options = {}, callback = () =&gt; {}) {
    // TODO
}</pre><p></p>
<p>
	再也不用去费力判断哪一个参数才是callback了。 Babel已经完全支持默认参数一些强大的语法，如
</p>
<p></p><pre class="crayon-plain-tag">function f([x, y] = [1, 2], {z: z} = {z: 3}) { 
    return x + y + z; 
}</pre><p></p>
<h3>
	对象属性缩写<br />
</h3>
<p></p><pre class="crayon-plain-tag">const url = &#39;http://www.alloyteam.com&#39;;
const type = &#39;GET&#39;;
const timeout = 10000;
$.ajax({
    url, type, timeout
});</pre><p></p>
<p>
	转换成
</p>
<p></p><pre class="crayon-plain-tag">var url = &#39;http://www.alloyteam.com&#39;;
var type = &#39;GET&#39;;
var timeout = 10000;
$.ajax({
    url: url,
    type: type,
    timeout: timeout
});</pre><p></p>
<p>
	属性缩写还可与解构赋值搭配使用
</p>
<p></p><pre class="crayon-plain-tag">// options: {url: url, type: type, timeout: timeout}
const {url, type} = options;
const opt = {url, type};</pre><p></p>
<p>
	这样轻松就能让opt成为options的一个子集了，在做字段过滤和参数白名单过滤的时候很有用。
</p>
<p>
	好了，时间已经很晚了，本期就先写到这里了。</p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/08/its-time-to-use-es2015/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>NodeJS中的EventEmitter模块</title>
		<link>http://www.alloyteam.com/2015/08/eventemitter/</link>
		<comments>http://www.alloyteam.com/2015/08/eventemitter/#comments</comments>
		<pubDate>Mon, 31 Aug 2015 13:46:31 +0000</pubDate>
		<dc:creator><![CDATA[TAT.joey]]></dc:creator>
				<category><![CDATA[Web开发]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=8204</guid>
		<description><![CDATA[EventEmitter简单介绍 在Nodejs中，异步的I/O 操作在完成时会触发事件队列中的具体事件。这里 [&#8230;]]]></description>
				<content:encoded><![CDATA[<h2>
	EventEmitter简单介绍<br />
</h2>
<p>
	在Nodejs中，异步的I/O 操作在完成时会触发事件队列中的具体事件。这里的主要原因是这些对象本质上是通过继承EventEmitter来实现对事件的处理和回调，如文件的file读写等。（这里的事件与DOM树上事件不同，不存在事件冒泡和捕获的情况。） <span id="more-8204"></span>我们也可以让自定义的对象通过继承EventEmitter来让其走观察者模式（事件监听与触发），主要通过EventEmitter的on和emit这些方法来构成。也有更为具体的API。如emitter.once(event,listener)添加一次性 listener（这个 listener 只会被触发一次，触发完成后就被删除）。
</p>
<h2>
	EventEmitter主要API<br />
</h2>
<p>
	emitter.on(event, listener) 注册一个事件。
</p>
<p>
	emitter.once(event, listener) 注册一个一次性的事件，触发后就被抹掉。
</p>
<p>
	emitter.removeListener(event, listener) 在时间队列中剔除某一个事件
</p>
<p>
	emitter.removeAllListeners([event]) 删除整个事件队列，或多个事件
</p>
<p>
	emitter.listeners(event) 返回某些事件 emitter.emit(event, [arg1], [arg2], [&#8230;]) 触发事件，可传入具体参数
</p>
<h2>
	使用EventEmitter的方式<br />
</h2>
<h3>
	1. 直接实例化获取EventEmitter<br />
</h3>
<p></p><pre class="crayon-plain-tag">var events = require(&#39;events&#39;);

// 实例化EventEmitter
var emitter = new events.EventEmitter();

// 绑定sayHi事件
// 可以绑定多个同名事件，触发时会顺序触发
emitter.on(&#39;sayHi&#39;, function(someone){
    console.log(&quot;我是&quot;, someone)
})
emitter.on(&#39;sayHi&#39;, function(someone){
    console.log(&quot;我就是&quot;, someone)
})

// 触发sayHi事件
emitter.emit(&#39;sayHi&#39;, &#39;jerry&#39;);

// 输出

// 我是jerry
// 我就是jerry</pre><p></p>
<h3>
	2. 通过继承来获取事件对象的方法<br />
</h3>
<p></p><pre class="crayon-plain-tag">// 引用util工具方便继承
var util = require(&#39;util&#39;);

var events = require(&#39;events&#39;);

// 创建自定义对象
var Cat = function (name) {
    this.name = name;
}

// 继承events.EventEmitter
util.inherits(Cat, events.EventEmitter);

// 创建自定义对象实例
var Tom = new Cat(&#39;Tom&#39;);

// 绑定sayHiTo事件
Tom.on(&#39;sayHi&#39;, function(someone){
    // this指向实例Tom
    console.log(this.name,&quot; sayHiTo &quot;, someone)
})

Tom.emit(&#39;sayHiTo&#39;, &#39;jerry&#39;)

// 输出

// Tom sayHiTo jerry</pre><p></p>
<h2>
	EventEmitter 其他API<br />
</h2>
<h3>
	emitter.once(event, listener)<br />
</h3>
<p>
	emitter.once是一次性监听，触发一次后，监听将被移除，并返回false
</p>
<p></p><pre class="crayon-plain-tag">var EventEmitter = require(&#39;events&#39;).EventEmitter;   
var emitter = new EventEmitter();

emitter.once(&#39;sayHi&#39;, function(someone) {
    console.log(someone);
});


emitter.emit(&#39;sayHi&#39;, &#39;jerry&#39;);

// 输出

// sayHi jerry

var res =  emitter.emit(&#39;sayHi&#39;, &#39;jerry&#39;);

// 无输出，res为false</pre><p></p>
<h3>
	emitter.removeListener(event, listener)<br />
</h3>
<p>
	移除监听事件的对应的listener
</p>
<p></p><pre class="crayon-plain-tag">var EventEmitter = require(&#39;events&#39;).EventEmitter;   
var emitter = new EventEmitter();

emitter.on(&#39;sayHi&#39;, function(someone) {
    console.log(someone);
});


emitter.removeListener(&#39;sayHi&#39;, function(){
    console.log(&#39;sayHi event&#39;);        
});

emitter.emit(&#39;jerry&#39;);

// 输出： jerry</pre><p></p>
<p>
	上面代码仍然输出了jerry，原因在于removeListener(event, listener)中的listener需要是注册到event事件中的函数。而不是removeListener执行完了之后的回调函数。 所以要如下进行删除listener
</p>
<p></p><pre class="crayon-plain-tag">var EventEmitter = require(&#39;events&#39;).EventEmitter;   
var emitter = new EventEmitter();

var sayHiCallBack = function(someone){
    console.log(someone);
}
emitter.on(&#39;sayHi&#39;, sayHiCallBack);

emitter.removeListener(&#39;sayHi&#39;,sayHiCallBack);        

emitter.emit(&#39;jerry&#39;);

// 无输出。即成功remove了sayHi事件</pre><p></p>
<p>
	EventEmitter为node的事件注册和分发提供了较好的形式。提高的代码的可读性及维护的便利性。</p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/08/eventemitter/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>手机上的位置传感器</title>
		<link>http://www.alloyteam.com/2015/08/mobile-phone-location-on-the-sensor/</link>
		<comments>http://www.alloyteam.com/2015/08/mobile-phone-location-on-the-sensor/#comments</comments>
		<pubDate>Mon, 31 Aug 2015 10:52:38 +0000</pubDate>
		<dc:creator><![CDATA[TAT.sheran]]></dc:creator>
				<category><![CDATA[HTML5]]></category>
		<category><![CDATA[移动 Web 开发]]></category>
		<category><![CDATA[geolocation]]></category>
		<category><![CDATA[位置传感器]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=8198</guid>
		<description><![CDATA[位置传感器 &#160; 1&#160;GPS与基站定位 位置传感器通常主要指手机内部的Global&#038;nbsp [&#8230;]]]></description>
				<content:encoded><![CDATA[<h2>
	位置传感器<br />
</h2>
<p>
	&nbsp;
</p>
<p>
	1&nbsp;GPS与基站定位
</p>
<p>
	位置传感器通常主要指手机内部的Global&nbsp;Positioning&nbsp;System&nbsp;(GPS)模块，GPS又称全球卫星定位系统，该系统包括太空中的24颗GPS卫星；地面上1个主控站、3个数据注入站和5个监测站及作为用户端的GPS接收机。最少只需其中3颗卫星，就能迅速确定用户端在地球上所处的位置及海拔高度；所能收联接到的卫星数越多，解码出来的位置就越精确。
</p>
<p>
	获取位置信息，核心在于获取经纬度坐标，继而在手机地图中标注出自身坐标，从而确定当前所处的位置。目前手机定位的方式有两种，一种是基于GPS的定位，一种是基于移动运营网的基站的定位。基于GPS的定位方式是利用手机上的GPS定位模块将自己的位置信号发送到定位后台来实现手机定位的。基站定位则是利用基站对手机的距离的测算距离来确定手机位置的。后者不需要手机具有GPS定位能力，但是精度很大程度依赖于基站的分布及覆盖范围的大小，有时误差会超过一公里。前者定位精度较高。
</p>
<p>
	<span id="more-8198"></span>
</p>
<p>
	<a href="http://cdn.alloyteam.com/wp-content/uploads/2015/08/图片1.jpg"><img alt="图片1" class="alignnone size-medium wp-image-8199" src="http://cdn.alloyteam.com/wp-content/uploads/2015/08/图片1-300x225.jpg" style="height:225px; width:300px" /></a><br />
	[图.1&nbsp;ublox生产的GPS模块]
</p>
<p>
	实际应用中，设备位置信息的来源，除了GPS和基站定位，还包括通过IP地址、RFID、WIFI和蓝牙MAC地址推断，以及用户主动输入。
</p>
<p>
	&nbsp;
</p>
<p>
	2&nbsp;Geolocation&nbsp;API
</p>
<p>
	从安全性考虑，地理位置信息属于用户隐私，不恰当的暴露可能会为用户带来潜在的威胁。因此当浏览器需要获取设备信息时，必须获得用户主动确认：
</p>
<p>
	<a href="http://cdn.alloyteam.com/wp-content/uploads/2015/08/图片2.png"><img alt="图片2" class="alignnone size-medium wp-image-8200" src="http://cdn.alloyteam.com/wp-content/uploads/2015/08/图片2-300x190.png" style="height:190px; width:300px" /></a><br />
	[图.2&nbsp;请求位置弹框图]
</p>
<p>
	浏览器在获得用户许可后，也允许用户取消许可，并提供给用户更新或者删除过往位置信息的能力。
</p>
<p>
	我们依然是通过特性检测来判断：
</p>
<p></p><pre class="crayon-plain-tag">&nbsp;&nbsp;&nbsp;&nbsp;if(navigator.geolocation)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;支持返回地理位置信息
&nbsp;&nbsp;&nbsp;&nbsp;}</pre><p></p>
<p>
	地理位置接口提供了两个函数来获取用户的当前位置：getCurrentPosition、watchPosition。前者只获取一次设备位置信息，后者则是实时地获取设备位置信息，保持异步更新。
</p>
<p>
	&nbsp;
</p>
<p>
	&nbsp; &nbsp;2.1&nbsp;getCurrentPosition
</p>
<p>
	先看一个最基本的例子：
</p>
<p></p><pre class="crayon-plain-tag">&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;showMap(position)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(&#39;经度：&#39;&nbsp;+&nbsp;data.coords.longitude&nbsp;+&nbsp;&#39;&nbsp;纬度：&#39;&nbsp;+&nbsp;data.coords.latitude);
&nbsp;&nbsp;&nbsp;&nbsp;}</pre><p></p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;navigator.geolocation.getCurrentPosition(showMap);
</p>
<p>
	运行一下，位置询问框出现，确认后看到了弹出了经纬度信息，我们已经获取了一次当前设备的位置。
</p>
<p>
	getCurrentPosion的调用方式为&nbsp;<code>getCurrentPosition(onSuccess,&nbsp;onError,&nbsp;options)</code>，其中<code>onSuccess</code>（成功回调函数）是必要参数，另外两个都是可选参数。
</p>
<p>
	成功获取时，API返回一个包含地理位置信息的容器，包含两个属性<code>coords</code>（坐标）和<code>timestamp</code>（时间戳），其中<code>coords</code>包含经度、纬度、精确度（米）、海拔高度、移动速度等信息，可惜除了前三个数据必然有返回，后面的数据经常返回null无法使用。
</p>
<p>
	有的时候也会获取位置失败，此时我们可以通过失败回调函数处理：
</p>
<p></p><pre class="crayon-plain-tag">&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;onError&nbsp;=&nbsp;function(err){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(err.code)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;err.TIMEOUT:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;超时
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;err.PERMISSION_DENIED:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;用户拒绝获取地理位置
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;err.POSITION_UNAVAILABLE:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;位置不能确定
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;};</pre><p></p>
<p>
	至于第三个参数<code>options</code>，则支持三个子参数：
</p>
<p>
	1.&nbsp;<code>enableHighAccuracy</code>，是否启用高精度定位，当然，启用之后会延长定位时间，默认为false;<br />
	2.&nbsp;<code>timeout</code>，超时时间，如果在规定的时间内没获取到地理位置，则触发<code>onError</code>并带上超时错误码。默认不限时长；<br />
	3.&nbsp;<code>maximumAge</code>，缓存时长，如果为0则不缓存获取到的位置每次都去获取最新，如果大于0则在缓存时间内不会再去进行定位而是返回缓存数据，默认为0。
</p>
<p>
	&nbsp;
</p>
<p>
	&nbsp; &nbsp; 2.2&nbsp;watchPosition和clearWatch
</p>
<p>
	<code>watchPosition</code>的参数和<code>getCurrentPosition</code>一致，区别是<code>watchPosition</code>会在开始及每次用户位置发生变化的时候更新地理位置触发成功回调，这在导航类应用场景非常实用。我们可以调用<code>clearWatch</code>清除位置监视，如下示例：&nbsp;
</p>
<p></p><pre class="crayon-plain-tag">&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;scrollMap(position)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;实时获取位置变化
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(&#39;经度：&#39;&nbsp;+&nbsp;data.coords.longitude&nbsp;+&nbsp;&#39;&nbsp;纬度：&#39;&nbsp;+&nbsp;data.coords.latitude);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;watchId&nbsp;=&nbsp;navigator.geolocation.watchPosition(scrollMap);
&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;buttonClickHandler()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;主动关闭位置更新
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;navigator.geolocation.clearWatch(watchId);
&nbsp;&nbsp;&nbsp;&nbsp;}</pre><p></p>
<p>
	这就是浏览器提供的地理位置API，使用它们我们的web页面就可以提供LBS服务及其他地理位置服务，变得更为强大。要注意的是获取地理位置可能会耗费一定时间，此时前台给用户一个等待反馈会提升用户体验，而实际应用场景中如何提升获取地理位置的精确度和效率，我们在后面的章节细讲。
</p>
<h4>
	&nbsp; &nbsp; 2.3兼容性<br />
</h4>
<p>
	地理位置API被以下桌面浏览器支持：
</p>
<p>
	*&nbsp;IE&nbsp;9+<br />
	*&nbsp;Firefox&nbsp;3.5+<br />
	*&nbsp;Chrome&nbsp;5+<br />
	*&nbsp;safari&nbsp;5+<br />
	*&nbsp;Opera&nbsp;16+
</p>
<p>
	以及以下移动设备浏览器支持：
</p>
<p>
	*&nbsp;iOS&nbsp;Safari&nbsp;3.2+<br />
	*&nbsp;Android&nbsp;Browser&nbsp;2.1+<br />
	*&nbsp;Chrome&nbsp;for&nbsp;Android
</p>
<p>
	*&nbsp;Firefox&nbsp;for&nbsp;Android&nbsp;38+
</p>
<p>
	*&nbsp;Opera&nbsp;mobile&nbsp;12+
</p>
<p>
	&nbsp;
</p>
<p>
	<a href="http://cdn.alloyteam.com/wp-content/uploads/2015/08/图片3.png"><img alt="图片3" class="alignnone size-medium wp-image-8201" src="http://cdn.alloyteam.com/wp-content/uploads/2015/08/图片3-300x132.png" style="height:132px; width:300px" /></a><br />
	[图N.2.3&nbsp;地理位置API支持情况]
</p>
<p>
	3案例：地理位置获取信息
</p>
<p>
	首先我们创建一个dom节点
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;geoloc&quot;&gt;&lt;/div&gt;
</p>
<p>
	判断浏览器支持<code>Geolocation&nbsp;API</code>后，通过参数的corrds属性就可以取到经纬度坐标了，如下
</p>
<p>
	&nbsp;
</p>
<p></p><pre class="crayon-plain-tag">&nbsp;&nbsp;&nbsp;&lt;script&gt;
&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;getElem(id)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;typeof&nbsp;id&nbsp;===&nbsp;&#39;string&#39;&nbsp;?&nbsp;document.getElementById(id)&nbsp;:&nbsp;id;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;show_it(lat,&nbsp;lon)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;str&nbsp;=&nbsp;&#39;您当前的位置，纬度：&#39;&nbsp;+&nbsp;lat&nbsp;+&nbsp;&#39;，经度：&#39;&nbsp;+&nbsp;lon;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getElem(&#39;geoloc&#39;).innerHTML&nbsp;=&nbsp;str;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(navigator.geolocation)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;navigator.geolocation.getCurrentPosition(function(position)&nbsp;{&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_it(position.coords.latitude,&nbsp;position.coords.longitude);&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;function(err)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getElem(&#39;geo_loc&#39;).innerHTML&nbsp;=&nbsp;err.code&nbsp;+&nbsp;&quot;\n&quot;&nbsp;+&nbsp;err.message;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getElem(&#39;geo_loc&#39;).innerHTML&nbsp;=&nbsp;&quot;您当前使用的浏览器不支持Geolocation服务&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;</pre><p></p>
<p>
	下一步我们要引入一个谷歌地图来定位，这里需要引入谷歌地图的API，如下
</p>
<p>
	&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;text/javascript&quot;&nbsp;src=&quot;http://maps.google.com/maps/api/js?sensor=false&quot;&gt;&lt;/script&gt;
</p>
<p>
	接着对获取经纬度的函数做一个改造
</p>
<p>
	&nbsp;&nbsp;&nbsp;
</p>
<p></p><pre class="crayon-plain-tag">&nbsp;&lt;script&gt;
&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;success(position)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;mapcanvas&nbsp;=&nbsp;document.createElement(&#39;div&#39;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapcanvas.id&nbsp;=&nbsp;&#39;mapcanvas&#39;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapcanvas.style.height&nbsp;=&nbsp;&#39;400px&#39;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapcanvas.style.width&nbsp;=&nbsp;&#39;560px&#39;;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getElem(&quot;map_canvas&quot;).appendChild(mapcanvas);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;latlng&nbsp;=&nbsp;new&nbsp;google.maps.LatLng(position.coords.latitude,&nbsp;position.coords.longitude);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;myOptions&nbsp;=&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zoom:&nbsp;15,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;center:&nbsp;latlng,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapTypeControl:&nbsp;false,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;navigationControlOptions:&nbsp;{style:&nbsp;google.maps.NavigationControlStyle.SMALL},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapTypeId:&nbsp;google.maps.MapTypeId.ROADMAP
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;map&nbsp;=&nbsp;new&nbsp;google.maps.Map(document.getElementById(&quot;mapcanvas&quot;),&nbsp;myOptions);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;marker&nbsp;=&nbsp;new&nbsp;google.maps.Marker({
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position:&nbsp;latlng,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map:&nbsp;map,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title:&quot;你在这里！&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(navigator.geolocation)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;navigator.geolocation.getCurrentPosition(success);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;</pre><p></p>
<p>
	如下图所示，我们已经获取到当前位置的地图坐标呈现
</p>
<p>
	<br />
	<a href="http://cdn.alloyteam.com/wp-content/uploads/2015/08/图片4.png"><img alt="图片4" class="alignnone size-medium wp-image-8202" src="http://cdn.alloyteam.com/wp-content/uploads/2015/08/图片4-300x167.png" style="height:167px; width:300px" /></a><br />
	[图N.3 笔者当前坐标位置]
</p>
<p>
	进一步地，根据地理位置坐标，通过公共API获取用户的&nbsp;天气信息&nbsp;&ndash;&nbsp;周边新闻&nbsp;&ndash;&nbsp;热点资讯&nbsp;等&hellip;<br />
	如QQ会员的用户关怀，与天气结合，如果是阴雨天气，红毛小Q以拟人姿态提醒用户多带把伞；晴好高温天气可以提醒用户擦防晒液防紫外线等&hellip;
</p>
<p>
	&nbsp;
</p>
<p>
	感谢大家阅读，同事感谢小伙伴junda对文章提出的专业建议！O(&cap;_&cap;)O</p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/08/mobile-phone-location-on-the-sensor/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>解读Node.js的cluster模块</title>
		<link>http://www.alloyteam.com/2015/08/nodejs-cluster-tutorial/</link>
		<comments>http://www.alloyteam.com/2015/08/nodejs-cluster-tutorial/#comments</comments>
		<pubDate>Mon, 31 Aug 2015 05:14:50 +0000</pubDate>
		<dc:creator><![CDATA[TAT.yunsheng]]></dc:creator>
				<category><![CDATA[Node.js]]></category>
		<category><![CDATA[Web开发]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=8173</guid>
		<description><![CDATA[&#160; &#160; &#160; &#160;在如今机器的CPU都是多核的背景下，Node的单线程设计 [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>
	&nbsp; &nbsp; &nbsp; &nbsp;在如今机器的CPU都是多核的背景下，Node的单线程设计已经没法更充分的&quot;压榨&quot;机器性能了。所以从v0.8开始，Node新增了一个内置模块&mdash;&mdash;&ldquo;cluster&rdquo;，故名思议，它可以通过一个父进程管理一坨子进程的方式来实现集群的功能。
</p>
<p>
	<span id="more-8173"></span>
</p>
<h2>
	快速上手<br />
</h2>
<p>
	使用十分的简单，如下
</p>
<p></p><pre class="crayon-plain-tag">var cluster = require(&#39;cluster&#39;);
var http = require(&#39;http&#39;);
var numCPUs = require(&#39;os&#39;).cpus().length; // 获取CPU的个数

if (cluster.isMaster) {
    for (var i = 0; i &amp;lt; numCPUs; i++) {
        cluster.fork();
    }

    cluster.on(&#39;exit&#39;, function(worker, code, signal) {
        console.log(&#39;worker &#39; + worker.process.pid + &#39; died&#39;);
    });
} else {
    http.createServer(function(req, res) {
        res.writeHead(200);
        res.end(&quot;hello world\n&quot;);
    }).listen(8000);
}</pre><p></p>
<p>
	稍微解释下，通过isMaster属性，判断是否Master进程，是则fork子进程，否则启动一个server。每个HTTP server都能监听到同一个端口。
</p>
<p>
	但是在实际项目中，我们的启动代码一般都已经封装在了app.js中，要把整块启动逻辑嵌在上面的if else中实在不优雅。 所以，我们可以这样：
</p>
<p></p><pre class="crayon-plain-tag">var cluster = require(&#39;cluster&#39;);
var numCPUs = require(&#39;os&#39;).cpus().length;

if (cluster.isMaster) {
    for (var i = 0; i &amp;lt; numCPUs; i++) {
        cluster.fork();
    }
    // 其它代码
    
} else {
    require(&quot;./app.js&quot;);
}</pre><p></p>
<p>
	简单之处就在于原本的应用逻辑根本不需要知道自己是在集群还是单边。（当然，如果应用在内存中维护了某些状态，比如session，就需要运用某些机制来共享了，这里不详说）
</p>
<p>
	&nbsp;
</p>
<h2>
	常用API<br />
</h2>
<p>
	cluster模块提供了一大坨事件和方法，这里挑一些常用的说明下，详细的请参考官方文档。
</p>
<h3>
	cluster.setupMaster([settings])<br />
</h3>
<p>
	setupMaster用来改变默认设置，只能被调用一次，调用后，配置会存在且冻结在cluster.settings里。配置只会影响fork时的行为，实际上这些选项就是传给fork用的，有兴趣的同学可以去对照child_process.fork()的参数。
</p>
<p>
	具体有如下选项：
</p>
<ul>
<li>
		execArgv Node执行时的变量数组，传递给node（默认为process.execArgv）。
	</li>
<li>
		exec 执行的文件，配置后就不需要像最开始的例子，在代码里require目标文件了（默认为process.argv[1]）。
	</li>
<li>
		args 传递给worker的变量数组（默认为process.argv.slice(2))）。
	</li>
<li>
		silent 是否禁止打印内容（默认为false）。
	</li>
<li>
		uid 设置进程的用户ID。
	</li>
<li>
		gid 设置进程的组ID。
	</li>
</ul>
<h3>
	Event: fork和online<br />
</h3>
<p>
	当一个新的worker被fork时就会触发fork事件，而在worker启动时才会触发online事件，所以fork先触发，online后触发。
</p>
<p>
	可以在这两个事件的callback里做些初始化的逻辑，也可以在这时向master报告：&ldquo;我起来了！&rdquo;。
</p>
<h3>
	Event: exit<br />
</h3>
<p>
	当任何一个worker停掉都会触发exit事件，可以在回调里增加fork动作重启。
</p>
<p>
	通过worker.suicide来判断，worker是意外中断还是主动停止的（在worker中调用kill和disconnect方法，视作suide。）。
</p>
<p></p><pre class="crayon-plain-tag">cluster.on(&#39;exit&#39;, function(worker, code, signal) {
    console.log(&#39;worker %d died (%s). restarting...&#39;,
        worker.process.pid, signal || code);
    cluster.fork();
});</pre><p></p>
<h3>
	cluster.worker和cluster.workers<br />
</h3>
<p>
	前者是一份worker对象的引用，只能在worker里使用。
</p>
<p>
	后者是master下对当前可用worker的一个Object，key为worker id，注意，当worker已经exit或disconnect后就不会在这个object里了。
</p>
<h3>
	Event: message<br />
</h3>
<p>
	message事件可以用来做master和worker的通信机制。 这里是个<a href="https://github.com/sitepoint-editors/node-cluster-tutorial/blob/master/communication.js">例子</a>&nbsp;。
</p>
<p>
	利用这套机制，可以用来实现不间断重启，<a href="https://github.com/sitepoint-editors/node-cluster-tutorial/blob/master/zero_downtime.js">代码</a>。
</p>
<p>
	文章最开始的例子有个问题，尤其是运行在生产环境还不够健壮：如果某个worker因为意外&ldquo;宕机&rdquo;了，代码并没有任何处理，这时如果我们重启应用又会造成服务中断。利用这些API就可以利用事件监听的方式做相应处理。
</p>
<p>
	&nbsp;
</p>
<h2>
	原理<br />
</h2>
<p>
	每个worker进程通过使用child_process.fork()函数，基于IPC（Inter-Process Communication，进程间通信），实现与master进程间通信。
</p>
<p>
	什么是fork，Linux API给了如下解释
</p>
<blockquote>
<p>
		fork() creates a new process by duplicating the calling process. The new process is referred to as the child process. The calling process is referred to as the parent process.
	</p>
<p>
		The child process and the parent process run in separate memory spaces. At the time of fork() both memory spaces have the same content. Memory writes, file mappings (mmap(2)), and unmappings (munmap(2)) performed by one of the processes do not affect the other.
	</p>
</blockquote>
<p>
	我们可以看到，fork出的子进程拥有和父进程一致的数据空间、堆、栈等资源（fork当时），但是是独立的，也就是说二者不能共享这些存储空间。 那我们直接用fork自己实现不就行了，干嘛需要cluster呢。
</p>
<blockquote>
<p>
		&ldquo;这样的方式仅仅实现了多进程。多进程运行还涉及父子进程通信，子进程管理，以及负载均衡等问题，这些特性cluster帮你实现了。&rdquo;
	</p>
</blockquote>
<p>
	这里再说下cluster的负载均衡。Node.js v0.11.2+的cluster模块使用了<a href="https://en.wikipedia.org/wiki/Round-robin_scheduling">round-robin</a>调度算法做负载均衡，新连接由主进程接受，然后由它选择一个可用的worker把连接交出去，说白了就是轮转法。算法很简单，但据官方说法，实测很高效。
</p>
<p>
	注意：在windows平台，默认使用的是<a href="https://msdn.microsoft.com/en-us/library/aa365198(VS.85).aspx">IOCP</a>，官方文档说一旦解决了分发handle对象的性能问题，就会改为RR算法（没有时间表。。）
</p>
<p>
	如果想用操作系统指定的算法，可以在fork新worker之前或者setupMaster()之前指定如下代码：
</p>
<p></p><pre class="crayon-plain-tag">cluster.schedulingPolicy = cluster.SCHED_NONE;</pre><p></p>
<p>
	或者通过环境变量的方式改变
</p>
<p></p><pre class="crayon-plain-tag">$ export NODE_CLUSTER_SCHED_POLICY=&quot;none&quot; # &quot;rr&quot; is round-robin
$ node app.js</pre><p></p>
<p>
	或在启动Node时指定
</p>
<p></p><pre class="crayon-plain-tag">$ env NODE_CLUSTER_SCHED_POLICY=&quot;none&quot; node app.js</pre><p></p>
<p>
	&nbsp;
</p>
<h2>
	使用pm2实现cluster<br />
</h2>
<p>
	<a href="https://github.com/Unitech/pm2">pm2</a>是一个现网进程管理的工具，可以做到不间断重启、负载均衡、集群管理等，比forever更强大。利用pm2可以做到<strong>no code but just config</strong>实现应用的cluster。
</p>
<p>
	安装pm2什么的这里就不赘述了。用pm2启动时，通过-i指定worker的数量即可。如果worker挂了，pm2会自动立刻重启，各种简单省心。
</p>
<p></p><pre class="crayon-plain-tag">$ pm2 start app.js -i 4</pre><p></p>
<p>
	<a href="http://cdn.alloyteam.com/wp-content/uploads/2015/08/pm5-port-release.png"><img alt="pm5-port-release" class="alignnone size-full wp-image-8185" src="http://cdn.alloyteam.com/wp-content/uploads/2015/08/pm5-port-release.png" style="height:268px; width:884px" /></a>
</p>
<p>
	也可以在应用运行时，改变worker的数量，如下图
</p>
<p>
	<a href="http://cdn.alloyteam.com/wp-content/uploads/2015/08/probe8.png"><img alt="probe8" class="alignnone size-full wp-image-8186" src="http://cdn.alloyteam.com/wp-content/uploads/2015/08/probe8.png" style="height:760px; width:891px" /></a>
</p>
<p>
	更多的使用方法，可以去github上慢慢看（说句题外话，如果有类似PM2，甚至更好的PM工具，欢迎在评论里回复^_^）。
</p>
<p>
	&nbsp;
</p>
<h2>
	多机器集群<br />
</h2>
<p>
	cluster适用于在单台机器上，如果应用的流量巨大，多机器是必然的。这时，反向代理就派上用场了，我们可以用node来写反向代理的服务（比如用<a href="https://github.com/nodejitsu/node-http-proxy">http-proxy</a>），好处是可以保持工程师技术栈的统一，不过生产环境，我们用的更多的还是nginx，这里就不多介绍了。
</p>
<p>
	&nbsp;
</p>
<h2>
	参考文章<br />
</h2>
<ul>
<li>
		<a href="https://strongloop.com/strongblog/whats-new-in-node-js-v0-12-cluster-round-robin-load-balancing/">What&rsquo;s New in Node.js v0.12: Cluster Round-Robin Load Balancing</a>
	</li>
<li>
		<a href="https://keymetrics.io/2015/03/26/pm2-clustering-made-easy/">Node.js clustering made easy with PM2</a>
	</li>
<li>
		<a href="https://codeforgeek.com/2014/12/cluster-node-js-performance/">Cluster in Node.js tutorial</a>
	</li>
<li>
		<a href="http://www.sitepoint.com/how-to-create-a-node-js-cluster-for-speeding-up-your-apps/">How to Create a Node.js Cluster for Speeding Up Your Apps</a>
	</li>
</ul>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/08/nodejs-cluster-tutorial/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>Don&#8217;t make me think：让用户思考过多是一种罪</title>
		<link>http://www.alloyteam.com/2015/08/dont-make-me-think-2/</link>
		<comments>http://www.alloyteam.com/2015/08/dont-make-me-think-2/#comments</comments>
		<pubDate>Sun, 30 Aug 2015 08:34:47 +0000</pubDate>
		<dc:creator><![CDATA[TAT.yana]]></dc:creator>
				<category><![CDATA[Web开发]]></category>
		<category><![CDATA[用户体验设计]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=8159</guid>
		<description><![CDATA[&#160; &#160; &#160; &#160; 最近读了Steve&#160;Krug的《Don&#038;rs [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>
	&nbsp; &nbsp; &nbsp; &nbsp; 最近读了Steve&nbsp;Krug的《Don&rsquo;t&nbsp;Make&nbsp;Me&nbsp;Think》，这本书对于Web和移动可用性设计有着很有趣的见解。对于其他可用性设计的书来说，这本书更加的浅显易懂。
</p>
<p>
	&nbsp;
</p>
<p>
	<strong>一、Don&#39;t make me think！！！</strong>
</p>
<p>
	&nbsp; &nbsp; &nbsp; &nbsp; 贯彻本书的一大定律就是：别让我思考！
</p>
<p>
	&nbsp; &nbsp; &nbsp; &nbsp; 作为这个信息爆炸的社会的一员，我们已经失去了耐心去仔细浏览Web或移动端页面内容的习惯。&ldquo;扫描&rdquo;，变成了人们使用网络的方式。中国传统观念对于&ldquo;不求甚解&rdquo;多含贬义，然而对于如今的我们，不求甚解已经成为了常态，那么如何让用户得到最舒服的体验呢？那就是不要让用户动脑思考。
</p>
<p>
	&nbsp;
</p>
<p><span id="more-8159"></span></p>
<p>
	<strong>二、那么我们应该怎样做呢？</strong>
</p>
<p>
	&nbsp; &nbsp; &nbsp; &nbsp;首先，<strong>尽量利用习惯用法</strong>。例如我们的习惯阅读文字的方式是从左向右，如果网页文字方向是从右向左，那真的不失为逼疯处女座的一种好方法；人们见到红色的第一反应是禁止，而绿色是可以通过，如果页面的禁止或拒绝标志被用了绿色，处女座就又一次疯掉了。所以，使用习惯用法是最安全的手段。
</p>
<p>
	&nbsp; &nbsp; &nbsp; &nbsp;第二，<strong>建立有效的视觉层次</strong>。越重要的部分就要越突出。如果一个页面没有清楚的视觉层次，用户就要更用力的去思考，降低了阅读的效率。
</p>
<p>
	&nbsp; &nbsp; &nbsp; &nbsp;第三，<strong>把页面划分成明确定义的区域</strong>。将页面划分区域后，用户就可以清楚的知道哪些感兴趣哪些可以跳过。比如AlloyTeam的导航栏，如果用户想要看到团队成员长得有多好看，那就可以点击&ldquo;团队&rdquo;；如果用户想要表达对AlloyTeam的爱慕之情就可以点击&ldquo;留言&rdquo;来向我们表白～
</p>
<p>
	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" src="http://cdn.alloyteam.com/wp-content/uploads/2015/08/2.3.png" />
</p>
<p>
	&nbsp; &nbsp; &nbsp; &nbsp;第四，<strong>明显标识可以点击的地方</strong>。无论是链接、按钮、选择卡等，都要有它自己应该有的样子，不要让用户去寻找什么是可以点击的。而CSS已经为我们提供了很好的解决方案。
</p>
<p>
	&nbsp; &nbsp; &nbsp; &nbsp;第五，<strong>将干扰降到最小</strong>。眼花缭乱的配色、乱七八糟的排列、过于密集的文字罗列&hellip;&hellip;再一次逼疯了处女座。用户的时间和精力有限，对于那些视觉上的噪声，该抛弃就抛弃吧！
</p>
<p>
	&nbsp; &nbsp; &nbsp; &nbsp;最后，<strong>为内容创建清楚的格式</strong>，以便扫描。用户一般都会先注意到字体最粗最显眼的标题的部分。给标题设置个讨喜的字体、让标题和它的正文紧密一点、不同的内容按照段落分开等等&hellip;&hellip;
</p>
<p>
	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt="" src="http://cdn.alloyteam.com/wp-content/uploads/2015/08/2.2-.png" />
</p>
<p>
	<strong>最后</strong>
</p>
<p>
	&nbsp; &nbsp; &nbsp; &nbsp; 可用性设计是Web开发中最重要的部分，《Don&#39;t make me think》给出了很多简单易学的可用性设计建议，非常适合我们Web开发人员阅读，推荐～</p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/08/dont-make-me-think-2/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>使用js实现思维导图</title>
		<link>http://www.alloyteam.com/2015/08/shi-yong-js-shi-xian-si-wei-dao-tu/</link>
		<comments>http://www.alloyteam.com/2015/08/shi-yong-js-shi-xian-si-wei-dao-tu/#comments</comments>
		<pubDate>Fri, 28 Aug 2015 10:25:05 +0000</pubDate>
		<dc:creator><![CDATA[TAT.rocket]]></dc:creator>
				<category><![CDATA[JavaScript]]></category>
		<category><![CDATA[Web开发]]></category>
		<category><![CDATA[作品]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=8125</guid>
		<description><![CDATA[本文主要阐述使用js实现思维导图的关键技术点，如果还不知道什么是思维导图的同学，请自行度娘。以下是demo和源 [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>
	本文主要阐述使用js实现思维导图的关键技术点，如果还不知道什么是思维导图的同学，请自行度娘。以下是demo和源码的传送门：<br />
	demo：<a href="http://rockyren.github.io/mindmaptree/">http://rockyren.github.io/mindmaptree/</a><br />
	源码：<a href="http://github.com/RockyRen/mindmaptree/tree/master">http://github.com/RockyRen/mindmaptree/tree/master</a>
</p>
<p>
	在源码中我使用了svg绘制思维导图。与canvas相比，svg将图像当成对象，我们可将思维导图中节点和线等图形表现为对象，而且svg更适合用于动态交互的应用
</p>
<p>
	<span id="more-8125"></span>下面介绍几个关键技术点：
</p>
<p>
	&nbsp;
</p>
<p>
	<span style="font-size:18px"><strong>子节点位置的重绘</strong></span><br />
	一个基本的思维导图工具应该拥有增加节点和删除节点的功能。在某个节点上增删节点时，为了使得所有子节点的高度相对于该节点垂直居中，都会重新渲染子节点的垂直位置。<br />
	如图1所示，首先求得父节点的中心点F的坐标为(hfx, hfy)，设父节点与子节点的水平距离为interval，父节点的宽为parentWidth。作水平线段FC，C点的横坐标即为子节点的横坐标childX。如下图所示：
</p>
<p>
	<img alt="" src="http://cdn.alloyteam.com/wp-content/uploads/2015/08/图1.png" style="height:268px; width:289px" />
</p>
<p>
	为了让子节点间垂直隔开，每一个子节点上下都有补白，所以一个子节点所占的区域高度为该子节点的节点高度加上两个补白高度。迭代所有子节点，求取所有子节点的区域高度areaHeight，然后在线段FC的C点上作一条长度为areaHeight的垂直平分线AB，所有子节点的垂直区域都在垂直平分线AB内，这样可以保证所有子节点的高度相对于该节点垂直居中。如下图所示：
</p>
<p>
	&nbsp;
</p>
<p>
	<img alt="" src="http://cdn.alloyteam.com/wp-content/uploads/2015/08/图2.png" style="height:326px; width:469px" />
</p>
<p>
	我们需要求得每一个子节点的垂直坐标childY。首先求得A点的垂直坐标startY = hfy &#8211; areaHeight / 2，第一个子节点的垂直坐标由startY加padding可得。求第二个子节点的垂直坐标时，startY累加上一个子节点的区域高度，则第二个子节点的垂直坐标等于当前startY加上padding。之后的子节点通过迭代相同的操作可得。在每一轮迭代中，根据求得的子节点坐标(childX, childY)渲染节点的位置。如下图所示：
</p>
<p>
	<img alt="" src="http://cdn.alloyteam.com/wp-content/uploads/2015/08/图3.png" style="height:336px; width:525px" />
</p>
<p>
	实现代码如下：
</p>
<p></p><pre class="crayon-plain-tag">// 以下变量请自行求得
var hfx,			// 父节点的中心x轴坐标
	hfy,			// 父节点的中心y轴坐标
	parentWidth, 	// 父节点的宽度
	children,		// 子节点列表
	padding,		// 子节点垂直间距
	interval;		// 节点间水平间距

var	childX,			// 子节点的x轴坐标
	startY,			// 子节点区域的起始坐标
	childrenAreaHeight = 0;		// 子节点总区域高度


childX = hfx + parentWidth / 2 + interval;

// 迭代子节点，求得子节点总区域高度
children.forEach(function(child){
	var curAreaHeight = getNodeHeight(child) + padding * 2;
	childrenAreaHeight += curAreaHeight;
});

startY = hfy - childrenAreaHeight / 2;
// 迭代子节点，求得每个子节点的垂直坐标
children.forEach(function(child){
	var childY = startY + padding;

	// 已经求得当前子节点坐标(childX, childY)，在这里作渲染操作

	var curAreaHeight = getNodeHeight(child) + padding * 2;
	startY += curAreaHeight;    // 其实高度累加
});


/**
 * 获取节点的高度
 */
function getNodeHeight(){
	// ...
}</pre><p></p>
<p>
	&nbsp;
</p>
<p>
	<span style="font-size:18px"><strong>祖先节点的同级节点的垂直位置调整</strong></span><br />
	如下图所示，当增加一个节点时，该节点父节点的同级节点需要被&ldquo;撑开&rdquo;：设该节点的1/2区域高度为moveY，在父节点的同级节点中，比父节点高的向上偏移一个moveY，比父节点低的向下偏移一个moveY。父节点的父节点的同级节点也做相同的处理，一直递归到根节点为止。当删除一个节点时，节点的父节点的同级节点会被&ldquo;压低&rdquo;，&ldquo;压低&rdquo;操作和上述操作相似。注意，当增加第一个子节点和删除最后一个子节点时，不会进行&ldquo;撑开&rdquo;和&ldquo;压低&rdquo;操作。
</p>
<p>
	<img alt="" src="http://cdn.alloyteam.com/wp-content/uploads/2015/08/moveY-e1440753663443.png" />
</p>
<p>
	实现源码如下：
</p>
<p></p><pre class="crayon-plain-tag">/**
 * 调整当前的父节点的同级节点的位置
 * @param node 当前的父节点, 以下为该节点需要用到的属性
 *              node.father: 节点的父节点，为null时表示父节点为根节点
 *              node.children:  节点的子节点列表
 *              node.x：  节点的x轴坐标
 *              node.y： 节点的y轴坐标
 *
 * @oaram areaHeight 被操作节点的区域高度
 */
function resetBrotherPosition(node, areaHeight){
    var brother,                    // 同级节点
        moveY = areaHeight / 2;     // 需要移动的高度
    if(node.father){
        node.father.children.forEach(function(curNode){
                // 遍历同级节点
                if(curNode != node){
                    if(brother.y &lt; node.y){
                        // 向上移动brother节点的代码写在这
                    }
                    else {
                        // 向下移动brother节点的代码写在这
                    }
                }
            }
        );
    }
    // 递归父节点
    if(node.father){
        resetBrotherPosition(node.father, areaHeight);
    }
}</pre><p></p>
<p>
	<span style="font-size:18px"><strong>拖动节点</strong></span><br />
	当拖动根节点时，通过改变svg的视口坐标来实现拖动整个思维导图的效果。当拖动<br />
	非根节点时，会按顺序触发mouseup、mousemove、mousedown三个事件，分别对应按下鼠标、鼠标移动和放下鼠标三个状态。在按下鼠标状态下，会以当前节点为原型克隆一个节点用于占位。在拖动鼠标状态下，通过改变节点的坐标实现节点位置的改变。在放下鼠标状态下，会判断当前节点是否与其他节点重叠，如果重叠则使重叠节点变为当前节点的父节点，否则，当前节点返回原来的位置。
</p>
<p>
	&nbsp;
</p>
<p>
	其他技术点我就不一一列出来了，有兴趣的同学可以到上面的传送门看看源码。</p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/08/shi-yong-js-shi-xian-si-wei-dao-tu/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>折线转曲线</title>
		<link>http://www.alloyteam.com/2015/08/zhe-xian-zhuan-qu-xian/</link>
		<comments>http://www.alloyteam.com/2015/08/zhe-xian-zhuan-qu-xian/#comments</comments>
		<pubDate>Tue, 25 Aug 2015 12:54:04 +0000</pubDate>
		<dc:creator><![CDATA[TAT.dnt]]></dc:creator>
				<category><![CDATA[Web开发]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=8106</guid>
		<description><![CDATA[写在前面 这个东西其实是有价值的东西。因为在软体模拟、数学方程可视化、流体模拟、数据可视化等等方面都有其用武之 [&#8230;]]]></description>
				<content:encoded><![CDATA[<h2>
	写在前面<br />
</h2>
<p>
	这个东西其实是有价值的东西。因为在软体模拟、数学方程可视化、流体模拟、数据可视化等等方面都有其用武之地。
</p>
<p>
	如水的模拟：
</p>
<p>
	<img alt="usage" src="http://images0.cnblogs.com/blog2015/105416/201508/251939571561058.png" />
</p>
<p>
	&nbsp;
</p>
<p><span id="more-8106"></span></p>
<p>
	心形函数方程转图像
</p>
<p>
	<img alt="usage" src="http://images0.cnblogs.com/blog2015/105416/201508/251940011098732.png" />
</p>
<p>
	线性报表
</p>
<p>
	<img alt="usage" src="http://images0.cnblogs.com/blog2015/105416/201508/251939511257781.png" />
</p>
<p>
	其原理都是通过三次贝塞尔曲线将有限个数的点平滑化。
</p>
<h2>
	问题建模<br />
</h2>
<p>
	已知若干个点，绘制出该点连接的曲线。
</p>
<p></p><pre class="crayon-plain-tag">​&lt;canvas width=&quot;480&quot; height=&quot;480&quot;&gt;&lt;/canvas&gt; 
&lt;script&gt; 
    function drawPath(path){ 
        //实现 
    } 

    drawPath([{ x: 50, y: 50 }, { x: 200, y: 100 }, { x: 250, y: 50 }, { x: 350, y: 150 }, { x: 370, y: 100 }, { x: 570, y: 200 }]) 
&lt;/script&gt;</pre><p></p>
<p>
	这里实验平台使用浏览器环境，即Canvas相关API以及javascript语言。
</p>
<p>
	这里canvas的上下文对象拥有了bezierCurveTo方法，故免去了自己实现bezierCurveTo的一些事情。
</p>
<p></p><pre class="crayon-plain-tag">​context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);</pre><p></p>
<h2>
	实现图解<br />
</h2>
<p>
	实现目标
</p>
<p>
	<img alt="usage" src="http://images0.cnblogs.com/blog2015/105416/201508/252022052033323.png" />
</p>
<p>
	具体过程<br />
	<img alt="usage" src="http://images0.cnblogs.com/blog2015/105416/201508/252022149062488.png" />
</p>
<h2>
	代码<br />
</h2>
<p>
	Vector2，一般用来表示向量，但有的时候也用来当作点来进行一计算。
</p>
<p></p><pre class="crayon-plain-tag">var Vector2 = function(x, y) { 
        this.x = x; 
        this.y = y; 
} 
Vector2.prototype = { 
    &quot;length&quot;: function () { 
        return Math.sqrt(this.x * this.x + this.y * this.y); 
    }, 
    &quot;normalize&quot;: function () { 
        var inv = 1 / this.length(); 
        return new Vector2(this.x * inv, this.y * inv); 
    }, 
    &quot;add&quot;: function (v) { 
        return new Vector2(this.x + v.x, this.y + v.y); 
    }, 
    &quot;multiply&quot;: function (f) { 
        return new Vector2(this.x * f, this.y * f); 
    }, 
    &quot;dot&quot;: function (v) { 
        return this.x * v.x + this.y * v.y; 
    }, 
    &quot;angle&quot;: function (v) { 
        return Math.acos(this.dot(v) / (this.length() *v.length())) * 180 / Math.PI; 
    } 
}</pre><p></p>
<p>
	其中<br />
	length求向量长度
</p>
<p>
	normalize转单位向量
</p>
<p>
	add向量叠加
</p>
<p>
	multiply向量翻倍
</p>
<p>
	dot内积
</p>
<p>
	angle方法用来求两个向量的夹角
</p>
<p>
	核心方法，根据path上的点，求出所有贝塞尔曲线控制点。
</p>
<p></p><pre class="crayon-plain-tag">​function getControlPoint(path) { 
    var rt = 0.3; 
    var i = 0, count = path.length - 2; 
    var arr = []; 
    for (; i &lt; count; i++) { 
        var a = path[i], b = path[i + 1], c = path[i + 2]; 
        var v1 = new Vector2(a.x - b.x, a.y - b.y); 
        var v2 = new Vector2(c.x - b.x, c.y - b.y); 
        var v1Len = v1.length(), v2Len = v2.length(); 
        var centerV = v1.normalize().add(v2.normalize()).normalize(); 
        var ncp1 = new Vector2(centerV.y, centerV.x * -1); 
        var ncp2 = new Vector2(centerV.y * -1, centerV.x); 
        if (ncp1.angle(v1) &lt; 90) { 
            var p1 = ncp1.multiply(v1Len * rt).add(b); 
            var p2 = ncp2.multiply(v2Len * rt).add(b); 
            arr.push(p1, p2) 
        } else { 
            var p1 = ncp1.multiply(v2Len * rt).add(b); 
            var p2 = ncp2.multiply(v1Len * rt).add(b); 
            arr.push(p2, p1) 
        } 
    } 
    return arr; 
}</pre><p></p>
<h2>
	Demo<br />
</h2>
<p>
	<a href="http://kmdjs.github.io/sm/">点我点我</a></p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/08/zhe-xian-zhuan-qu-xian/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
		<item>
		<title>【福利】乳摇动画初探</title>
		<link>http://www.alloyteam.com/2015/08/fu-li-ru-yao-dong-hua-chu-tan/</link>
		<comments>http://www.alloyteam.com/2015/08/fu-li-ru-yao-dong-hua-chu-tan/#comments</comments>
		<pubDate>Sun, 23 Aug 2015 10:58:23 +0000</pubDate>
		<dc:creator><![CDATA[TAT.vorshen]]></dc:creator>
				<category><![CDATA[Web开发]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=8099</guid>
		<description><![CDATA[咳，以探索技术的精神进行一些猥琐的实现，先说明，如果你只想看最后乳摇的结果那就请ctrl+F4吧，因为网上有那 [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>
	咳，以探索技术的精神进行一些猥琐的实现，先说明，如果你只想看最后乳摇的结果那就请ctrl+F4吧，因为网上有那些乳摇的APP，制作出来绝对比我这个初探的方法好，我这个只是介绍我实现乳摇的过程思路与方法。
</p>
<p>
	关于乳摇如何实现，我第一个想法是使用metaball，因为是两个球嘛，然而发现根本就不行，Fail。最终使用的是液化算法去实现。
</p>
<p>
	好了，下面是对液化算法的介绍。
</p>
<div>
	<span id="more-8099"></span>
</div>
<p>
	如果你从来不使用ps，暂时想不起来液化是什么不要紧，请看下图
</p>
<p>
	<img alt="" src="http://cdn.alloyteam.com/wp-content/uploads/2015/08/1.gif" style="height:349px; width:466px" />
</p>
<p>
	这个是采用液化使一只静态的小狗有了动的感觉
</p>
<p>
	总而言之，液化是使一张图片的部分进行平滑的有规律的变化，这个变化有扭曲的平移之感
</p>
<p>
	是如何实现的呢，来看算法，先给一张图
</p>
<p>
	<img alt="" src="http://cdn.alloyteam.com/wp-content/uploads/2015/08/2.png" style="height:506px; width:550px" />
</p>
<p>
	局部变化以一个圈为变化环境，C点是圆心，r是半径，当C移动到M这个点时，U移动到X。
</p>
<p>
	通过以上这句话我们得出了这样的结论：
</p>
<p>
	液化的变化只在半径为r的圆内发生，距离圆心越近，变化越明显。这是不是和乳摇这一现象特别的吻合？
</p>
<p>
	下面是算法公式
</p>
<p>
	<img alt="" src="http://cdn.alloyteam.com/wp-content/uploads/2015/08/3.png" style="height:93px; width:485px" />
</p>
<p>
	公式终于实现的是你知道X点的坐标，可以推算出U点的坐标，反之知道U点也可以推算出X的坐标
</p>
<p>
	怎么推算出来的这个我也不知道，需要结合圆的范围，进行插值处理，但是具体如何得到这个结论，感兴趣的同学可以阅读
</p>
<p>
	<span style="font-family:verdana,arial,helvetica,sans-serif; font-size:14px">Andreas Gustafsson 的&nbsp;</span><a href="http://www.gson.org/thesis/warping-thesis.pdf" style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); border-bottom-width: 1px; border-bottom-style: dotted; border-bottom-color: rgb(51, 51, 51); font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 25.2000007629395px;">Interactive Image Warping</a>一文，这个公式就是从这而来
</p>
<p>
	&nbsp;
</p>
<p>
	好了，接下来该码程序了
</p>
<p>
	乳摇首先你得有图
</p>
<p></p><pre class="crayon-plain-tag">var sImg = new Image();
sImg.src = &#39;./dd.png&#39;;

var leftImage = new Image();
leftImage.src = &#39;./dd_left.png&#39;;

var rightImage = new Image();
rightImage.src = &#39;./dd_right.png&#39;;

var timer = null;

sImg.onload = function() {
	oGC.drawImage(sImg, 0, 0);
};</pre><p></p>
<p>
	&nbsp;
</p>
<p>
	这里上来就有三张图，其中一张是完整的，还有两张分别是美女左右对半分开的【其实就是左胸和右胸】，因为需要这两张图进行乳摇【液化】后的还原。当然你也可以只用一张图，先取出还原的像素存起来也是可以的，我在这里偷懒了
</p>
<p>
	&nbsp;
</p>
<p></p><pre class="crayon-plain-tag">function liquify(imgData, cx, cy, mx, my, r) {
        var imgDataBuff = copyImageDataBuff(imgData);
        eachCircleDot(imgData, cx, cy, r, function(posi) {
            var tx = posi.x,
                ty = posi.y;
            var u = transFormula(cx, cy, mx, my, tx, ty, r);
            moveDot(imgData, imgDataBuff, posi, u);
            function transFormula(cx, cy, mx, my, tx, ty, r) {
                var relativity = sqr(r) - distanceSqr(tx, ty, cx, cy);
                var distanceMovedSqr = distanceSqr(mx, my, cx, cy);
                
                var rate = sqr(relativity / (relativity + distanceMovedSqr));
                
                var ux = (tx - rate*(mx-cx)),
                    uy = (ty - rate*(my-cy));
                return {
                    x: ux,
                    y: uy
                };
            }
        });
        return imgData;
    }</pre><p></p>
<p>
	&nbsp;
</p>
<p>
	上面是液化算法的函数，结合上面的图来看，参数分别是图片像素data，圆心C的x轴和y轴，M点的x轴和y轴，圆的半径r
</p>
<p>
	copyImageDataBuff是将将要液化部分的像素copy一份，代码如下
</p>
<p>
	&nbsp;
</p>
<p></p><pre class="crayon-plain-tag">function copyImageDataBuff(imgData) {
    var data = imgData.data,
        imgDataBuff = [];
        
    for(var i in data) {
        imgDataBuff[i] = data[i];
    }
    
    return imgDataBuff;
}</pre><p></p>
<p>
	&nbsp;
</p>
<p>
	eachCircleDot是将每个圆内的像素取出来进行处理
</p>
<p></p><pre class="crayon-plain-tag">function eachCircleDot(imageData, ox, oy, r, callback) {
		var imgWidth = imageData.width,
			imgHeight = imageData.height,
			data = imageData.data,
			left = ox - r,
			right = ox + r,
			top = oy - r,
			bottom = oy + r;

		for(var x = left; x &lt; right; x++) {
			for(var y = top; y &lt; bottom; y++) {
				if(distanceSqr(x,y,ox,oy) &lt;= sqr(r)) {
					callback({
						x: x,
						y: y
					});
				}
			}
		}
	}</pre><p></p>
<p>
	&nbsp;
</p>
<p>
	distanceSqr和sqr是求圆心距离和平方的函数，很简单
</p>
<p></p><pre class="crayon-plain-tag">function distanceSqr(x1, y1, x2, y2) {
	return sqr(x1 - x2) + sqr(y1 - y2);
}

function sqr(x) {
	return x * x;
}</pre><p></p>
<p>
	&nbsp;
</p>
<p>
	transFormula这个方法就是液化公式的使用，传入的是c点的x，y值、m点的x，y；t点就是上面图中的x点，return出来u点的x，y值之后传入moveDot，这个就是液化最终的表现函数
</p>
<p>
	&nbsp;
</p>
<p></p><pre class="crayon-plain-tag">function moveDot(imgData, dataBuff, posi, u) {
	var imgWidth = imgData.width,
		imgHeight = imgData.height,
		data = imgData.data;

	u.x = Math.floor(u.x);
	u.y = Math.floor(u.y);

	data[(posi.y * imgWidth + posi.x) * 4] = dataBuff[(u.y * imgWidth + u.x) * 4];
	data[(posi.y * imgWidth + posi.x) * 4 + 1] = dataBuff[(u.y * imgWidth + u.x) * 4 + 1];
	data[(posi.y * imgWidth + posi.x) * 4 + 2] = dataBuff[(u.y * imgWidth + u.x) * 4 + 2];
	data[(posi.y * imgWidth + posi.x) * 4 + 3] = dataBuff[(u.y * imgWidth + u.x) * 4 + 3];
}</pre><p></p>
<p>
	将公式算出的u点rgba信息换给之前的t点，也就是图中的x点，完成液化
</p>
<p>
	最终给个结果图
</p>
<p>
	<img alt="" src="http://images0.cnblogs.com/blog2015/740327/201508/231838083944385.gif" style="height:452px; width:304px" />
</p>
<p>
	因为只时间缘故（LPL决赛呢）只设置了左胸的摇动触发，触发代码如下
</p>
<p></p><pre class="crayon-plain-tag">var sX = 5;
var sY = 5;
var iX = -200;
var x = -10;
var iY = ev.clientY - oC.offsetTop;

if(iY &gt; 296) {
    iY = 200;
    y = 10;
} else {
    iY = -200;
    y = -10;
}

timer = setInterval(function() {
    oGC.drawImage(leftImage, 0, 0); // 只做了左半边的效果

    var d = oGC.getImageData(23, 140, 140, 200);

    var c = liquify(d, 60, 170, sX + 65, sY + 170, 58);

    oGC.putImageData(c, 23, 140);
    
    sX = sX + x;
    sY = sY + y;
    
    if(Math.abs(sX) &gt; Math.abs(iX) || Math.abs(sY) &gt; Math.abs(iY)) {
        clearInterval(timer);
    }
}, 30);</pre><p></p>
<p>
	&nbsp;
</p>
<p>
	这里面的数值都是自己测出来的，sX和sY是摇动的频率，getImageData的xywh四个值也是试出来的，意味着你想要胸变化的范围，注意：
</p>
<p>
	这个范围必须要比液化公式中的圆大
</p>
<p>
	iY和y是根据点击在胸上方还是胸下方来确定摇动的方向
</p>
<p>
	liquify传入的参数已经介绍过了
</p>
<hr />
<p>
	这次的乳摇还是很初步的，只是优化了速度，最早还有一个版本非常的卡，demo就不放出来了&hellip;&hellip;一些幅度，方向都很简单，而且是写死的，如果你有兴趣可以更多的去优化和添加功能~</p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/08/fu-li-ru-yao-dong-hua-chu-tan/feed/</wfw:commentRss>
		<slash:comments>6</slash:comments>
		</item>
		<item>
		<title>VPS 捣鼓小记</title>
		<link>http://www.alloyteam.com/2015/08/vps-notes/</link>
		<comments>http://www.alloyteam.com/2015/08/vps-notes/#comments</comments>
		<pubDate>Sat, 22 Aug 2015 16:01:25 +0000</pubDate>
		<dc:creator><![CDATA[TAT.felix]]></dc:creator>
				<category><![CDATA[Web开发]]></category>
		<category><![CDATA[vps]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=8090</guid>
		<description><![CDATA[不作死就不会死， 不捣鼓就不会活 &#8212; via 菲利克斯&#183;肖恩莱特 什么是作死？作死就 [&#8230;]]]></description>
				<content:encoded><![CDATA[<blockquote>
<p>
		不作死就不会死， 不捣鼓就不会活 &#8212; via 菲利克斯&middot;肖恩莱特
	</p>
</blockquote>
<p>
	什么是作死？作死就是不懂原理乱写代码，不懂环境乱配，不懂工具乱用，打掉一个 bug 再怀上一个 bug，伤元气瞎折腾。
</p>
<p>
	什么是捣鼓？捣鼓和作死相反，在解决问题时力求寻因导果，既能解决问题，又能学到新知识拓展新视野。
</p>
<p>
	在最近折腾 VPS 的时候，我就不断在作死，才捣鼓出了新乐趣，写下来和大家分享一下。
</p>
<p>
	<span id="more-8090"></span>
</p>
<p>
	作为一个没有服务器端编程经验的小前端，为何要去折腾 VPS 呢？因为能学到很多东西啊，举几个栗子:
</p>
<ul>
<li>
<p>
			搭建个博客写点文章啊
		</p>
</li>
<li>
<p>
			既然搭建博客了，那要搞域名啊、CDN啊、加缓存啊、打补丁啊、流量分析啊、性能分析啊、写主题啊、优化访问速度啊、提高 SEO 啊
		</p>
</li>
<li>
<p>
			搭建个 VPN/shadowsock 配个代理锻炼锻炼身体又能科学上网啊，还可能省点钱啊
		</p>
</li>
<li>
<p>
			哎呀好多操作都是 Linux 还是纯命令行操作的，能学到不少 Linux 知识啊
		</p>
</li>
<li>
<p>
			女朋友不陪你折腾你还可以折腾 VPS 啊
		</p>
<p>
			&nbsp;
		</p>
</li>
</ul>
<h1>
	从购买一个 VPS 开始<br />
</h1>
<p>
	要过情人节，首先你得上淘宝买个不会漏气的女朋友。
</p>
<p>
	同理，你想折腾 VPS 你得买个靠谱的服务器。
</p>
<p>
	比如，你想访问速度快一些，可以选择购买腾讯云或阿里云提供的服务器；如果你想更自由一些，可以选择国外 Linode 或者 DigitalOcean 等提供的服务器。选择腾讯云可以使用<a href="http://www.qcloud.com/redirect.php?redirect=1001&amp;cps_key=50b46969b6fa53f1334070ccf5a941d0" style="box-sizing: border-box; color: rgb(64, 120, 192); background-color: transparent;">我们的推荐链接</a>, 选择 Linode 则可以使用<a href="https://www.linode.com/?r=e815823fd4ebad47aef51ae07250b626d30b7f40" style="box-sizing: border-box; color: rgb(64, 120, 192); background-color: transparent;">这个链接</a>。腾讯云最低配只需 65块，Linode最低配也只需要10美金，具体的配置和价格，可以自己去仔细对比下。
</p>
<p>
	好了，有了充气娃娃，噢不，是服务器，我们就可以放心地上了。
</p>
<p>
	使用 ssh 进行登录，假定服务提供商给你的 IP 是 11.22.33.44, 帐号是 root, 密码是 passwd：
</p>
<p></p><pre class="crayon-plain-tag">$ ssh root@11.22.33.44</pre><p></p>
<p>
	输入密码，第一次登录后建立公钥，我们就和成功上到了服务器。
</p>
<p>
	接着要怎么玩呢？什么姿势舒服就怎么玩嘛。
</p>
<p>
	好了，文章到此结束，我回家找女朋友了。
</p>
<p>
	&#8212;&#8212;&#8212;&#8212;我是回家的分界线&#8212;&#8212;&#8212;&#8212;
</p>
<p>
	快递还没到，我先上一下 VPS 玩一玩好了。
</p>
<h1>
	快速实战，试手 VPS 迁移<br />
</h1>
<p>
	哎呀~ 想起不少人吐槽过我们团队的&nbsp;<a href="http://www.alloyteam.com/" style="box-sizing: border-box; color: rgb(64, 120, 192); background-color: transparent;">博客</a>&nbsp;打开速度太慢了，都超过了 12 秒，这怎么能忍？
</p>
<p>
	没办法，忍辱负重，我只能趁女朋友还没到之前，快速优化一下（希望 12 秒内可以解决）。
</p>
<p>
	嗯，先分析下博客为什么访问那么慢？
</p>
<ol>
<li>
<p>
			服务器在国外，国内连接过去太远了！
		</p>
</li>
<li>
<p>
			使用的是 WordPress 程序，安装了不少冗余插件！
		</p>
</li>
<li>
<p>
			HTTP 请求数量太多了，就和女生上厕所一样，得排队才能完啊！
		</p>
</li>
<li>
<p>
			Google Analytics 等一些服务器已经被墙！
		</p>
</li>
<li>
<p>
			用户上传图片太大，没有经过压缩处理！
		</p>
</li>
</ol>
<p>
	好吧，那我们就先进行初步的优化。
</p>
<h1>
	VPS 数据迁移<br />
</h1>
<p>
	服务器搬家到国内，也就是 Linode 别人家搬回自己家腾讯云，得带上老老少少一家人：
</p>
<ul>
<li>
<p>
			网站代码
		</p>
</li>
<li>
<p>
			Nginx 配置
		</p>
</li>
<li>
<p>
			数据库数据
		</p>
</li>
</ul>
<p>
	嗯，学到的第一个 linux 终于派上了用场，将这些数据打包：
</p>
<p></p><pre class="crayon-plain-tag">// tar 将文件进行打包
// -c 表示创建归档
// -z 表示使用 gzip 压缩
// -v 表示打包时显示进度
// -f 指定压缩后的文件名，如 all.tar.gz 
$ tar -czvf  all.tar.gz /path/to/sites  /path/to/nginx.conf /path/to/database</pre><p></p>
<p>
	好了，数据量不小，打包后的文件非常大，问题就来了，选哪个交通工具呢？
</p>
<ul>
<li>
<p>
			wget 或 curl 简单便携
		</p>
</li>
<li>
<p>
			ftp 也是简单便携
		</p>
</li>
<li>
<p>
			scp 加密传输
		</p>
</li>
<li>
<p>
			rsync 增量传输
		</p>
</li>
<li>
<p>
			dropbox 中转传输
		</p>
</li>
</ul>
<p>
	wget 或 curl 和 ftp 下载的方式很简单。
</p>
<p>
	scp 和 rsync下载的方式是加密传输，也常用于两个主机之间进行复制文件（需要先建立 ssh 连接）。
</p>
<p>
	scp 使用加密进行传输，可以在两个主机中进行复制：
</p>
<p></p><pre class="crayon-plain-tag">// 先登录 A 主机后，将 B 主机 11.22.33.44 上的 /home/data/ 复制到 A 主机下的 /home/data/
// -r 表示遍历复制目录下的所有文件
$ scp -r root@11.22.33.44:/home/data/ /home/data/ 
// 若为建立 ssh 连接，则输入后需要输入 A 主机的登录密码</pre><p></p>
<p>
	rsync 传输也加密，但能将文件夹、文件等的权限等信息也保存下来，采用流式传输，同时是一种增量备份的算法在支持，效率较高：
</p>
<p></p><pre class="crayon-plain-tag">// 先登录 A 主机后，将 B 主机 11.22.33.44 上的 /home/data/ 复制到 A 主机下的 /home/data/
// -a 表示使用归档模式，保持所有文件属性
// -v 表示显示传输进度
// -r 表示遍历复制目录下的所有文件
// -z 表示进行压缩处理
// -e 指定一些端口信息
$ rsync -avrz -e &#39;ssh -p 22&#39; root@11.22.33.44:/home/data  /home/data/</pre><p></p>
<p>
	嗯，小结一下：
</p>
<ul>
<li>
<p>
			对于单次传输来看，可以使用 wget/curl/ftp;
		</p>
</li>
<li>
<p>
			对于重要数据，可以使用 scp 来传输;
		</p>
</li>
<li>
<p>
			如果有日常备份的需要，可以使用 rsync 来传输（增量备份）;
		</p>
</li>
</ul>
<p>
	然后，在这次搬家中，这些工具都没什么卵用，腾讯云和 Linode 就像情侣，终究输给了距离：国内外物理距离太远了，都只有几K/s的传输速度，说什么距离不是问题山盟海誓爱你加密都没用。
</p>
<p>
	感情出现危机，自然就需要云备胎作为支持。
</p>
<p>
	也就是使用 Dropbox 或百度云进行中转。
</p>
<p>
	<a href="https://www.dropbox.com/developers/apps" style="box-sizing: border-box; color: rgb(64, 120, 192); background-color: transparent;">Dropbox</a>&nbsp;服务器也在国外，果真是和 Linode 近水楼台先得月，传输速度高达 5M/s, 正当腾讯云准备好一切将一家老少迎接回家时，却又被判了死刑：Dropbox 再高再帅再快也在墙外啊，门不当户不对你们不可以结婚！这时候还有个&nbsp;<a href="https://github.com/houtianze/bypy" style="box-sizing: border-box; color: rgb(64, 120, 192); background-color: transparent;">bypy</a>&nbsp;的百度云第三方接口可以舒缓下情绪，可这个接口非官方支持，不确定是否可靠，不可作为长期的备份方案，我也无力再爱，所以也没再出轨。
</p>
<p>
	这个故事告诉我们，生活就是如此无奈，我们活在别人界定的环境里，不让你玩你就是不能玩！
</p>
<p>
	等到我们下一代出生时，他们已然不知道这世界上有谷歌、推特、脸书，只有我们知道我们自由的圈子越来越小。
</p>
<p>
	扯远了，回到正题。
</p>
<p>
	既然数据已经在了 Dropbox 中转区，数据搬迁也是一次性的，索性就停止了作死，使用 sftp 将压缩包下载到了本地，同样再使用 sftp 将数据上传到了新服务器上。
</p>
<h1>
	VPS 环境搭建与恢复<br />
</h1>
<p>
	接着的事情就简单了，新服务器上恢复环境。
</p>
<ul>
<li>
		安装好所需要的工具（如 Nginx/Mysql/PHP/Git 等)
	</li>
</ul>
<p></p><pre class="crayon-plain-tag">$ apt-get install nginx mysql-server mysql-client php5-fpm</pre><p></p>
<ul>
<li>
		配置好所需要的用户和权限
	</li>
</ul>
<p>
	添加用户：
</p>
<p></p><pre class="crayon-plain-tag">// 添加新用户 laixiaolai
$ useradd laixiaolai
// 给新用户设置密码
$ passwd ***********</pre><p></p>
<p>
	添加用户组：
</p>
<p></p><pre class="crayon-plain-tag">$ groupadd handsomeboys
// 将 laixiaolai 加入这个用户组
$ usermod -G handsomeboys laixiaolai</pre><p></p>
<p>
	设置一些目录的归属：
</p>
<p></p><pre class="crayon-plain-tag">// 授予 laixiaolai 一个池塘
$ chown -R laixiaolai:handsomeboys /data/girlpool</pre><p></p>
<p>
	有趣吧，在 linux VPS 下，自己掌控用户和权限的感觉，好像我这一匹野马拥有了一个草原呐~
</p>
<ul>
<li>
		恢复数据库备份
	</li>
</ul>
<p>
	不同数据库自有不同的恢复指令，简单举 mysql 做个栗子：
</p>
<p></p><pre class="crayon-plain-tag">// 将 dump_girls_db.sql 这个数据库备份，导入到本机 localhost 的 girls_db 数据库中
// -h 表示主机名
// -u 表示用户名，注意这里是 mysql 的用户名而不是 VPS 服务器的用户名
// -p 表示输入密码
$ mysql -hlocalhost -uroot -p girls_db &lt; dump_girls_db.sql</pre><p></p>
<ul>
<li>
		启动所需要的服务
	</li>
</ul>
<p>
	启动各种服务
</p>
<p></p><pre class="crayon-plain-tag">// 启动各种程序
$ service nginx start
$ service php5-fpm start
$ service mysql
// 重启和关闭类似
// service nginx stop</pre><p></p>
<p>
	作死点：注意新旧机子的系统差异，以及新旧软件的配置差异，比如 ubuntu 系统上装的是 php5-fpm 而在 cent 系统中可能就是 php-fpm，不同系统或者不同版本软件安装后，默认用户、权限可能也不一致。 所以，出了问题应该这么排查：
</p>
<ul>
<li>
<p>
			需要的依赖都装完了么
		</p>
</li>
<li>
<p>
			需要的软件都启动正常么，如 $ service nginx status 查看 Nginx 是否运行正常
		</p>
</li>
<li>
<p>
			启动程序的用户和用户组对么，如 $ chown -R userA:group1 /data/ 将 /data/ 的拥有权赋予 group1 用户组中的用户 userA
		</p>
</li>
<li>
<p>
			程序对特定的目录或文件有足够的权限么，如 $ chmod 777 autobackup.sh 给这个 shell 执行权限
		</p>
</li>
<li>
<p>
			知道怎么看各种错误日志么，如 $ tail /var/log/nginx/nginx_error.log 查看 nginx 的错误日志
		</p>
</li>
</ul>
<p>
	到了这里，一家老少都搬回了国内安顿好了，这时候就可以开启下一步了：改善他们的生活。
</p>
<h1>
	博客服务器简单优化<br />
</h1>
<p>
	把玩博客只是把玩 VPS 的一个小部分，这里就简单介绍下基于 WordPress 程序的博客优化过程：
</p>
<ul>
<li>
<p>
			删除冗余插件，这个没得说了，清理冗余的不靠谱的插件
		</p>
</li>
<li>
<p>
			批量压缩图片等静态资源文件，配合 gulp/grunt 插件使用即可，或使用 wordpress 插件
		</p>
</li>
<li>
<p>
			静态资源 CDN 化，迁移到腾讯云 CDN 上，减轻 HTTP 请求压缩，加快访问速度
		</p>
</li>
<li>
<p>
			开启数据库级别的缓存
		</p>
</li>
<li>
<p>
			开启 PHP 程序级别的缓存
		</p>
</li>
<li>
<p>
			使用 wp-super-cache 插件开启静态页面生成
		</p>
</li>
</ul>
<p>
	经过简单处理后，博客访问速度大大提升了，当然，还可以继续优化下去。
</p>
<p>
	常访问我们&nbsp;<a href="http://www.alloyteam.com/" style="box-sizing: border-box; color: rgb(64, 120, 192); background-color: transparent;">博客</a>&nbsp;的朋友，这时候应该能感觉到访问速度有提升吧？欢迎关注我们团队的博文分享。
</p>
<h1>
	VPS 数据要备份备份备份！<br />
</h1>
<p>
	不怕一万就怕万一，有数据备份习惯的人总是不会吃亏，这和要有备胎是一样的道理。
</p>
<p>
	需要备份的数据和之前说过要迁移的数据是差不多的，而备份和迁移的区别在于：
</p>
<ul>
<li>
<p>
			备份需要定期进行
		</p>
</li>
<li>
<p>
			备份可能需要保留多版本
		</p>
</li>
<li>
<p>
			备份存在多个物理机上最好（异地容灾）
		</p>
</li>
<li>
<p>
			备份有时候需要实时备份（增量传输）
		</p>
</li>
<li>
<p>
			及时删除冗余备份
		</p>
</li>
<li>
<p>
			备份应该切片，方便快速恢复
		</p>
</li>
</ul>
<p>
	那么，可选的方式是怎样的呢？
</p>
<ul>
<li>
<p>
			完整物理机全盘备份，这个需要服务器提供商支持（Linode 支持，而国内云都暂不支持）
		</p>
</li>
<li>
<p>
			使用 ftp 定时备份，需要时可以手动进行（手动肯定不如自动）
		</p>
</li>
<li>
<p>
			使用 rsync 增量安全备份，可以设置多个物理机分时备份（异地容灾）
		</p>
</li>
<li>
<p>
			使用 Dropbox（Dropbox 官方 API 提供，但被墙）
		</p>
</li>
<li>
<p>
			使用 cron + git 的方式定时备份（自定义 cron 定时任务，加上 git 打标签进行版本管理）
		</p>
</li>
</ul>
<p>
	最优方式是 rsync/cron+git 啦，rsync 不再赘述，介绍下 cron+git 方式吧。
</p>
<h1>
	cron 自动执行定时任务<br />
</h1>
<p>
	举个栗子，我想要备份一个文件 /data/sites/laiblog/content/data/ghost.db：
</p>
<p>
	要使用 Git 将数据进行自动备份，先编写 /data/sites/laiblog/autobackup.sh 脚本
</p>
<p></p><pre class="crayon-plain-tag">#!/bin/sh
# PATH=/opt/someApp/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
# 获取当前时间
DATE_ALL=`date +%Y-%m-%d_%H.%M.%S`
# 切换到 git 项目目录
cd /data/sites/laiblog/
# 备份这个 ghost.db 文件
# 注意要指定绝对路径，因为测试时你使用相对路径自然是能执行成功
# 但 cron 执行这个 shell 时，所在的目录和你测试时可能不一致，导致找不到路径
# 添加文件修改
git add /data/sites/laiblog/content/data/ghost.db
git commit -m &quot;自动备份&quot;
// 推送要远程仓库备份
git push
# 用时间戳打 tag 并推送到仓库，方便找到这个版本
# v$DATE_ALL 表示以时间为 tag
git tag -a v$DATE_ALL -m &#39;auto backup&#39;
git push origin v$DATE_ALL:v$DATE_ALL</pre><p></p>
<p>
	注意要设置这个文件为可执行模式：
</p>
<p></p><pre class="crayon-plain-tag">$ chmod 755 /data/sites/laiblog/autobackup.sh</pre><p></p>
<p>
	再使用 crontab 设置定时任务
</p>
<p></p><pre class="crayon-plain-tag">// 编辑 crontab 任务
$ crontab -e</pre><p></p>
<p>
	接着在打开的文件中添加：
</p>
<p></p><pre class="crayon-plain-tag"># 格式是：m    h    dom   mon   dow   command
# 即     分钟 小时  日期  月份   周几   命令
# dom  是 day of month
# mon  是 month
# dow  是 day of week
# 如以下：每天凌晨 4 点 59 分执行 autobackup.sh 的脚本
# 2&gt; 表示将错误输出到 crontab-autobackup.log 中，调试时有用
59 4 * * * /data/sites/laiblog/autobackup.sh 2&gt; /data/sites/laiblog/crontab-autobackup.log</pre><p></p>
<p>
	注意这个 autoback.sh 脚本使用 git push 时并没有输入帐号密码，是因为设置了全局使用 ssh 连接 git 仓库的方式。
</p>
<h1>
	免输入帐号密码使用 git pull/push<br />
</h1>
<p>
	使用你的邮箱生成密钥/公钥：
</p>
<p></p><pre class="crayon-plain-tag">$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@gmail.com&quot;</pre><p></p>
<p>
	生成后打开 ssh-agent:
</p>
<p></p><pre class="crayon-plain-tag">$ eval &quot;$(ssh-agent -s)&quot;</pre><p></p>
<p>
	将公钥添加到 ssh-agent 中：
</p>
<p></p><pre class="crayon-plain-tag">ssh-add ~/.ssh/id_rsa</pre><p></p>
<p>
	复制生成的公钥：
</p>
<p></p><pre class="crayon-plain-tag">$ pbcopy &lt; ~/.ssh/id_rsa.pub</pre><p></p>
<p>
	将公钥添加到 git 仓库的（如 github 的添加地址为：<a href="https://github.com/settings/ssh%EF%BC%89" style="box-sizing: border-box; color: rgb(64, 120, 192); background-color: transparent;">https://github.com/settings/ssh）</a>
</p>
<p>
	修改远程仓库的 url 为 ssh 方式，如：
</p>
<p></p><pre class="crayon-plain-tag">$ git remote set-url origin git@github.com:yourUserName/yourProjectRepo.git</pre><p></p>
<p>
	这么一来，就不用每次 git pull/push 都要输入帐号密码了。
</p>
<h1>
	VPS 折腾总结<br />
</h1>
<ul>
<li>
<p>
			不作死就不会死，Linux 中用户和权限相关的知识非常重要，这往往决定了程序是否能够正常运行以及服务器是否安全。
		</p>
</li>
<li>
<p>
			边折腾边学习，掌握问题背后的原因。
		</p>
</li>
<li>
<p>
			学习到很好有趣的命令，比如：
		</p>
</li>
</ul>
<p></p><pre class="crayon-plain-tag">// 查看硬盘（剩余）空间
$ df -h 

// 查看文件夹占用空间
// -d 表示计算 1 层目录，利用这个我们可以从根目录开始执行这个指令，层层下去查看到底是哪里占用了太多空间以瘦身
$ du -h -d 1

// 查看特定文件并计算数量
// find ./ 表示在当前目录开始查找
// -name &quot;*.png&quot; 表示查找以 .png 为后缀的文件
// | 是 *nix 中流式传输的思想，意为将前面程序的输出结果，当作后续程序的输入源
// wc -l 表示计算数量，并将其列出
$ find ./ -name &quot;*.png&quot; | wc -l</pre><p></p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/08/vps-notes/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
		</item>
		<item>
		<title>2015·腾讯AlloyTeam招聘·Web+工程师</title>
		<link>http://www.alloyteam.com/2015/08/2015-teng-xun-alloyteam-zhao-pin-web-qian-duan-gong-cheng-shi/</link>
		<comments>http://www.alloyteam.com/2015/08/2015-teng-xun-alloyteam-zhao-pin-web-qian-duan-gong-cheng-shi/#comments</comments>
		<pubDate>Mon, 10 Aug 2015 03:05:17 +0000</pubDate>
		<dc:creator><![CDATA[TAT.Alloy]]></dc:creator>
				<category><![CDATA[Web开发]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=8062</guid>
		<description><![CDATA[腾讯AlloyTeam开始社会招聘啦，想加入AlloyTeam的Web+（UI、JS、Server、Clien [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>
	腾讯AlloyTeam开始社会招聘啦，想加入AlloyTeam的Web+（UI、JS、Server、Client）工程师们请抓紧！工作职责主要负责腾讯手机QQ、PC QQ中的Web业务开发。如果你热爱面向Web的开发工作，欢迎前来应聘，机会难得，各种挑战等着你～～
</p>
<h2>
	岗位名称：Web前端开发工程师（<span style="color:rgb(255, 102, 0)">T2-T3</span>级别）<br />
</h2>
<h2>
	<span id="more-8062"></span>岗位要求：<br />
</h2>
<ul>
<li>
		计算机专业或相关专业大学本科以上学历，2年以上工作经验（如果你足够牛，可以尝试挑战一下这一条）。
	</li>
<li>
		精通W3C标准的网站构建，有构建高性能的Web应用的经验。
	</li>
<li>
		熟悉Web性能优化，有移动Web开发经验者优先。
	</li>
<li>
		熟悉WebView性能优化，有相关终端开发经验者优先考虑。
	</li>
<li>
		熟悉Javascript、OOP及主流js库，有框架开发经验者优先考虑。
	</li>
<li>
		熟悉HTML5和CSS3等新技术。
	</li>
<li>
		具有良好的代码风格、接口设计与程序架构。
	</li>
<li>
		掌握至少一门服务器端编程语言
	</li>
<li>
		对业界最新的前端技术和实现有浓厚的兴趣及深入的见解。
	</li>
<li>
		逻辑分析能力强，善于沟通，较强的学习能力，具备良好的沟通能力和团队协作精神。
	</li>
</ul>
<h2>
	工作职责：<br />
</h2>
<div>
<ul>
<li>
			负责腾讯手机QQ、 PC QQ的Web前端开发
		</li>
<li>
			构建前端生态的工具开发
		</li>
<li>
			移动Web性能探索和调优
		</li>
<li>
			其他Web相关开发
		</li>
</ul>
</div>
<h2>
	工作地点：<br />
</h2>
<ul>
<li>
		深圳腾讯大厦（总部）
	</li>
</ul>
<p>
	如果你相信自己，相信W3C标准，也相信爱情，请发送简历至：<strong>Kinvix[a]QQ.com</strong></p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/08/2015-teng-xun-alloyteam-zhao-pin-web-qian-duan-gong-cheng-shi/feed/</wfw:commentRss>
		<slash:comments>15</slash:comments>
		</item>
		<item>
		<title>[译文]web workers到底有多快？</title>
		<link>http://www.alloyteam.com/2015/08/web-worker/</link>
		<comments>http://www.alloyteam.com/2015/08/web-worker/#comments</comments>
		<pubDate>Sun, 02 Aug 2015 04:15:58 +0000</pubDate>
		<dc:creator><![CDATA[TAT.joey]]></dc:creator>
				<category><![CDATA[Web开发]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=7980</guid>
		<description><![CDATA[来源：How fast are web workers? 下一版本的 Firefox OS 移动操作系统将通过 [&#8230;]]]></description>
				<content:encoded><![CDATA[<h5>来源：<a href="https://hacks.mozilla.org/2015/07/how-fast-are-web-workers/">How fast are web workers?</a></h5>
<p>下一版本的 Firefox OS 移动操作系统将通过使用其多核处理器来充分利用设备的性能，JavaScript虽然在单线程上执行，但通过使用web workers可以实现代码的并行执行，这样将释放浏览器中任何可能阻塞主线程的程序，UI动画也将因此更顺畅的执行。<span id="more-7980"></span></p>
<h3><a id="user-content-web-workers-简介" class="anchor" href="https://github.com/JoeyGoo/doc/tree/master/web%20workers#web-workers-简介"></a>web workers 简介</h3>
<p>有几种类型的web workers：</p>
<ul>
<li><a href="https://hacks.mozilla.org/2015/07/how-fast-are-web-workers/">Web workers</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker">Shared workers</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">Service workers</a></li>
</ul>
<p>他们各自拥有不同特性，但有着相似的设计形式，worker中代码将在自己开辟的独立线程上执行，与主线程及其他worker并行执行，不同类型的workers维护着一个共同的接口。</p>
<h4><a id="user-content-web-workers" class="anchor" href="https://github.com/JoeyGoo/doc/tree/master/web%20workers#web-workers"></a>web workers</h4>
<p>专用的web workers将在主线程上被实例化，并且其他worker将只能通过它来进行通信</p>
<h4><a id="user-content-shared-workers" class="anchor" href="https://github.com/JoeyGoo/doc/tree/master/web%20workers#shared-workers"></a>Shared workers</h4>
<p>Shared workers 允许同源中的所有页面或脚本(包含不同的浏览器标签, iframes或者其他 shared workers)之间进行通信.</p>
<h4><a id="user-content-service-workers" class="anchor" href="https://github.com/JoeyGoo/doc/tree/master/web%20workers#service-workers"></a>Service workers</h4>
<p>近期，Service workers 得到了大量的关注，他可以作为web代理服务器(开发者能够对页面请求进行控制)将内容传递给请求者(如主线程)。不仅如此，它还能够支持离线应用。Service workers是一个非常新的API，现在仍没有兼容所有的浏览器，本文将不对其详细介绍。</p>
<p>为了验证web workers让Firefox OS运行得更快,我们通过对其进行基准测试来验证他的速度。</p>
<h3><a id="user-content-创建web-workers的开销" class="anchor" href="https://github.com/JoeyGoo/doc/tree/master/web%20workers#创建web-workers的开销"></a>创建web workers的开销</h3>
<p>本文主要针对Firefox OS。所有的数据都在Flame手机上所测量。 第一组测试是创建 web workers所花费的时间，为此，我们创建一个script文件，该script文件实例化了一个web worker并发送一个最小的消息。发现web worker快速对其回复。当主线程接收到响应后，我们将得到这个过程所花费的时间。 然后销毁web worker并对上面所述的实验进行多次重复操作，我们将能够得到创建web worker所花费的平均时间，可以通过如下代码简单地实例化一个web worker</p>
<div class="highlight highlight-JavaScript">
<pre class="crayon-plain-tag">// Start a worker.
var worker = new Worker('worker-script.js');

// Terminate a worker.
worker.terminate();</pre>
</div>
<p>同样的方式来创建广播通道</p><pre class="crayon-plain-tag">// Open a broadcast channel.
var channel = new window.BroadcastChannel('channel-name');

// Close a broadcast channel.
channel.close();</pre><p>Shared workers 无法在这里进行基准测试，因为他们一旦被创建，开发者将不能够销毁他们，它们将由浏览器接管。鉴于此，我们不能通过创建和销毁 Shared workers来得到有意义的基准测试。</p>
<p>Web workers大约使用40毫秒被实例化。这个时间相当稳定的，波动只有几毫秒。创建一个broadcast channel 通常是在1毫秒内完成。</p>
<p>正常情况下，浏览器的刷新频率为60帧/秒(fps)，这意味着没有JavaScript代码运行应该超过一帧所需时间,即16.66毫秒(60帧/秒)。否则页面的渲染就会出现卡顿效果，也就是常说的jankiness。</p>
<p>实例化web workers非常高效的，但是仍可能不适合单帧所用的时间。这就是为什么要创造尽可能少的web workers并且重用它们的重要原因。</p>
<h3><a id="user-content-消息延迟" class="anchor" href="https://github.com/JoeyGoo/doc/tree/master/web%20workers#消息延迟"></a>消息延迟</h3>
<p>web workers的关键之一，是它能够在主线程及workers之间进行快速通信，以下列出主线程与web worker之间两种不同的通信方式。</p>
<h4><a id="user-content-postmessage" class="anchor" href="https://github.com/JoeyGoo/doc/tree/master/web%20workers#postmessage"></a>postMessage</h4>
<p>这个API是默认及首选的，用来web worker发送和接收消息。如下:<br />
<code></code></p><pre class="crayon-plain-tag">// Send a message to the worker.
worker.postMessage(myMessage);
 
// Listen to messages from the worker.
worker.onmessage = evt =&gt; {
  var message = evt.data;
};</pre><p></p>
<h4><a id="user-content-broadcast-channel" class="anchor" href="https://github.com/JoeyGoo/doc/tree/master/web%20workers#broadcast-channel"></a>Broadcast Channel</h4>
<p>这是一个新的API,现在只能在Firefox中使用。Broadcast Channel能够所有同源的上下文进行广播消息。包含同源的页面,iframes,或workers都能够发送和接收消息:</p><pre class="crayon-plain-tag">// Send a message to the broadcast channel.
channel.postMessage(myMessage);

// Listen to messages from the broadcast channel.
channel.onmessage = evt =&gt; {
  var message = evt.data;
};</pre><p>这里的基准测试，我们使用类似于上述代码，不同之处在于web worker将不被销毁，并在每一个操作都重复使用它。所以，得到的往返响应时间应除以2。 可能你已想到，简单的postMessage是很快的，它通常只需要在0至1毫秒来发送一个消息，不管是对一个web还是shared worker。Broadcast channel的API大约需要1至2毫秒。</p>
<p>在正常情况下，workers之间通信很快，你不需要担心这里的通信速度，当然，发送更大的消息将会使用较长的时间。</p>
<h4><a id="user-content-消息的大小" class="anchor" href="https://github.com/JoeyGoo/doc/tree/master/web%20workers#消息的大小"></a>消息的大小</h4>
<p>有两种形式能够给web workers发送消息</p>
<ul>
<li>Copying the message</li>
<li>Transferring the message</li>
</ul>
<p>在第一种情况下，该消息将被序列化，复制然后发送。在后者，数据将被传送，这意味着消息发送出去后，发送者将不再使用它。数据传送几乎是瞬时的，所以不能基准测试。然而，只有ArrayBuffer是可传送的。</p>
<p>正如预期，序列化、复制和反序列化数据对消息传输增加了显著的开销。消息越大，时间越长。</p>
<p>在这个基准测试中，我们发送一个 typed array 给 web worker。 它的大小在每个迭代中逐步增加。传送消息的大小跟传输时间呈线性相关。对于每次测量,我们可以把数据大小（kb）除以时间（ms）来得到传输速度（kb/ms）。</p>
<p>通常，在Flame手机中，postMessage的传输速度在80 kB/ms，而broadcast channel则为12kB/ms，这意味着，如果你想你的消息适应单个帧，那么当使用postMessage时，让消息的大小保持在1300kB内；在使用broadcast channel时，使其大小小于200kB。否则，可能会出现丢帧的情况。</p>
<p>在这个基准测试中，我们使用typed array，因为它使我们能够以千字节为单位确定其大小。你也可以传输JavaScript对象，但由于序列化的过程,他们需要更长的时间去发送。对于小的对象，这其实并不重要，但如果你需要发送巨大的对象，你不妨将其序列化成二进制格式。并且使用类似于协议缓冲区的方式。</p>
<h4><a id="user-content-正常使用下web-workers相当快" class="anchor" href="https://github.com/JoeyGoo/doc/tree/master/web%20workers#正常使用下web-workers相当快"></a>正常使用下Web workers相当快</h4>
<p>以下是在Flame 手机中对web workers的各种基准测试的总结:</p>
<p>** 操作 ** -》 ** 值 **</p>
<ul>
<li>实例化一个web worker -》 40 ms</li>
<li>实例化一个broadcast channel -》 1 ms</li>
<li>postMessage 的通信延迟 -》 0.5 ms</li>
<li>broadcast channel的通信延迟 -》 1.5 ms</li>
<li>postMessage的通信速度 -》 80 kB/ms</li>
<li>broadcast channel的通信速度 -》 12 kB/ms</li>
<li>postMessage的最大传输数据大小 -》 1,300 kB</li>
<li>broadcast channel的最大传输数据大小 -》 200 kB</li>
</ul>
<p>基准测试用来确保你所使用的解决方案是非常快的。这个过程将大量的猜测从web开发中消除。</p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/08/web-worker/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Angular2使用体验</title>
		<link>http://www.alloyteam.com/2015/07/angular2-shi-yong-ti-yan/</link>
		<comments>http://www.alloyteam.com/2015/07/angular2-shi-yong-ti-yan/#comments</comments>
		<pubDate>Fri, 31 Jul 2015 15:51:45 +0000</pubDate>
		<dc:creator><![CDATA[TAT.simplehuang]]></dc:creator>
				<category><![CDATA[Web开发]]></category>
		<category><![CDATA[移动 Web 开发]]></category>
		<category><![CDATA[经验心得]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=8035</guid>
		<description><![CDATA[Angular2开发者预览版出来已有一段时间，这个以速度与移动性能为目的的框架到底如何，今天我们来尝试一下。  [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>Angular2开发者预览版出来已有一段时间，这个以速度与移动性能为目的的框架到底如何，今天我们来尝试一下。</p>
<p>在官网有一段号称5分钟入门的教程：</p>
<p>quick start： <a href="https://angular.io/docs/js/latest/quickstart.html">https://angular.io/docs/js/latest/quickstart.html</a></p>
<p><span id="more-8035"></span></p>
<p>Angular团队在这个版本上所做的改变可以用激进来形容，我们可以看得到无论是在代码书写亦或是结构组织上都有了非常大的差异，那么，既然Angular1.x已经如此成熟了，那为何我们还需要Angular2这样大的改变呢？</p>
<p>其实无论是Angular2还是ReactNative，他们都肩负了前端许多的愿景，既然目前的前端环境调优已经基本达到巅峰，那么从原生、另一门语言的角度去审视改良只是我们突破与超越的小小尝试而已。</p>
<p>那么Angular2与1.x对比在写法与上手难度上到底有什么区别呢？</p>
<p>下面我将用Angular2来制作一个Todo示例应用：</p>
<p>在完成了初始化任务后，首先，确保我们的TypeScript编译监控处于启用状态，以下语句是作为ts文件修改编译监控：</p><pre class="crayon-plain-tag">$ tsc --watch -m commonjs -t es5 --emitDecoratorMetadata app.ts</pre><p>&nbsp;</p>
<p>整理一下我们的思路，文件结构应该是这样的：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/QQ图片20150731233155.png"><img class="alignnone size-full wp-image-8036" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/QQ图片20150731233155.png" alt="QQ图片20150731233155" width="306" height="204" /></a></p>
<p>我们看到了熟悉的app.js文件,这是以app.ts编译过后的产物，app.ts:</p><pre class="crayon-plain-tag">/// &lt;reference path="../../typings/angular2/angular2.d.ts" /&gt;

import {Component, View, bootstrap, For, If} from "angular2/angular2";
import {TodoStore} from 'services/todo/TodoStore';

@Component({
    selector: 'app',
    injectables: [TodoStore]//注入TodoStore
})

@View({
    template: `&lt;div class="page-header"&gt;
                &lt;div class="form-group"&gt;
                 &lt;div class="input-group"&gt;
                  &lt;div class="input-group-addon"&gt;Todo&lt;/div&gt;
                  &lt;input type="text" class="form-control" 
                   placeholder="输入TodoItem" autofocus #newtodo 
                   (keyup)="add($event,newtodo)"&gt;
                 &lt;/div&gt;
                &lt;/div&gt;
                &lt;ul class="list-group"&gt;
                 &lt;li class="list-group-item" *for="#todo of todoStore.todoList"&gt;
                  &lt;input type="checkbox" [checked]="todo.done" 
                   (click)="toggleTodoState(todo)"/&gt; 
                  &lt;span [class.done]="todo.done"&gt;{{todo.text}}&lt;/span&gt;
                 &lt;/li&gt;
                &lt;/ul&gt;
               &lt;/div&gt;`,
    directives: [For, If]
})

class AppComponent {
    todoStore : TodoStore;

    constructor(todoStore: TodoStore) {
	this.todoStore = todoStore;
    }

    add($event,newtodo){
	if($event.which === 13){//判断是否回车键
	    this.todoStore.add(newtodo.value);
	    newtodo.value = '';
	}
    }

    toggleTodoState(todo){
	todo.done = !todo.done;//反转done值
    }
}

bootstrap(AppComponent);</pre><p>在当前版本中，Template关键字已经被替换为View关键字，文档传送门：<a href="https://angular.io/docs/js/latest/api/annotations/ViewAnnotation-class.html">View</a></p>
<p>inde.html（墙内用户推荐将traceur-runtime.js/system.src.js/angular2.dev.js这几个文件保存在本地，这样可以不必忍受各种404，超时加载）:</p><pre class="crayon-plain-tag">&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Angular 2 Test&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="styles/bootstrap.min.css"&gt;
    &lt;script src="lib/traceur-runtime.js"&gt;&lt;/script&gt;
    &lt;script src="lib/system.src.js"&gt;&lt;/script&gt;
    &lt;script src="lib/angular2.dev.js"&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;!-- The app component created in app.ts --&gt;
    &lt;app&gt;&lt;/app&gt;
    &lt;script&gt;
    System.import('app');
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre><p>services/todo/todo.ts:</p><pre class="crayon-plain-tag">export class TodoStore {
    constructor(){
        this.todoList = [];
    }
    add(item){
        this.todoList.unshift({text:item,done:false,style:'bg-success'});
    }
}</pre><p>运行示例：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/QQ图片20150731233925.png"><img class="alignnone size-full wp-image-8037" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/QQ图片20150731233925.png" alt="QQ图片20150731233925" width="369" height="220" /></a></p>
<p>&nbsp;</p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/07/angular2-shi-yong-ti-yan/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
		</item>
		<item>
		<title>flow&#8211;facebook出品的javascript静态类型检查器</title>
		<link>http://www.alloyteam.com/2015/07/flow-a-static-type-checker-for-javascript-from-facebook/</link>
		<comments>http://www.alloyteam.com/2015/07/flow-a-static-type-checker-for-javascript-from-facebook/#comments</comments>
		<pubDate>Fri, 31 Jul 2015 14:31:45 +0000</pubDate>
		<dc:creator><![CDATA[TAT.will]]></dc:creator>
				<category><![CDATA[JavaScript]]></category>
		<category><![CDATA[Web开发]]></category>
		<category><![CDATA[资源工具]]></category>
		<category><![CDATA[facebook]]></category>
		<category><![CDATA[前端工具]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=8014</guid>
		<description><![CDATA[起源 众所周知，js是一门弱类型的语言，类型转换往往隐含在各种业务代码中，同时也埋下了不少的坑。比如以下代码  [&#8230;]]]></description>
				<content:encoded><![CDATA[<article class="markdown-body">
<h2 class="markdown-body">起源</h2>
<p>众所周知，js是一门弱类型的语言，类型转换往往隐含在各种业务代码中，同时也埋下了不少的坑。比如以下代码</p><pre class="crayon-plain-tag">// return string
function getEnvVersion(){
    return '1.1.1';
}

// '1.1.1' &gt; 0 =&gt; false, so nothing happen
if(getEnvVersion() &gt; 0){
    // doSthAwesome();
}</pre><p><span id="more-8014"></span></p><pre class="crayon-plain-tag">function size(obj){
    return obj.length;
}
// uncaught error
size(null);</pre><p>类似的情况数不胜数，通过jshint工具做一些编码规范可以规避一些问题，但由于js过于灵活，还是有许多无法检查到的隐患。</p>
<h2></h2>
<h2>FLOW</h2>
<p>于是flow出现了。<a href="http://flowtype.org" target="_blank">flow</a>是facebook推出的js类型检查工具，可以在编码时检查到类型错误并做出提示，避免将问题带上线。</p>
<h3>安装</h3>
<p>目前flow仅支持MacOS与Linux，可以直接在官网wget最新的二进制包到本地运行。</p>
<h4>MacOS</h4>
<p>Mac用户推荐使用<code>brew install flow</code>完成安装。</p>
<h3>快速上手</h3>
<p>只需要在待检查的js文件头部添加一行注释<code>/* @flow */</code>，然后在同一目录下运行<code>flow check</code>即可。<br />
<a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/flow1.png"><img class="alignnone  wp-image-8022" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/flow1.png" alt="flow1" width="601" height="436" /></a></p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/flow2.png"><img class="alignnone  wp-image-8020" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/flow2.png" alt="flow2" width="600" height="344" /></a><br />
代码中增加类型检查，即可通过flow的检测了。<br />
<a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/flow3.png"><img class="alignnone size-full wp-image-8023" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/flow3.png" alt="flow3" width="518" height="510" /></a></p>
<h2>详细使用</h2>
<h3>类型标注</h3>
<p>正如前文所说，js的类型转换很灵活，比如如下代码</p><pre class="crayon-plain-tag">function add(num1, num2){
    return num1 + num2;
}
add(3, '0')</pre><p>结果会是多少呢？3? &#8217;30&#8217;? 相信很多人知道，结果是&#8217;30&#8217;。绝大多数情况下，这不是我们想要的结果。如果让flow来检测这段代码，会是什么结果呢？<br />
<a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/flow4.png"><img class="alignnone  wp-image-8024" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/flow4.png" alt="flow4" width="347" height="239" /></a><br />
是的，flow不会报错，因为<code>+</code>操作符对于字符串和数字都是完全适用的，而且<code>add</code>函数也没有声明参数必须是数字。<br />
加上类型标注之后，flow就检测到了。<br />
<a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/flow5.png"><img class="alignnone  wp-image-8021" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/flow5.png" alt="flow5" width="560" height="372" /></a><br />
是不是隐隐觉得有什么地方不对？没错，js不支持类型声明啊(/= _ =)/~┴┴ 这玩意上线怎么跑啊？<br />
别急，这里使用了JSX的语法，使用对应的转换工具即可去掉类型声明用于生产环境。</p><pre class="crayon-plain-tag">npm install -g jstransform
jstransform --strip-types --harmony --watch src/ build/</pre><p>以上命令可以让<code>jstransform</code>在后台检测src目录下的文件，并实时编译到build目录下。</p>
<h3>开发环境与持续集成</h3>
<h4>flow server</h4>
<p>如果每次一点代码小改动，都手动运行<code>flow check</code>来检查所有文件，想想都觉得蛋疼。<br />
flow提供了后台静默运行的方式，可以只检测改变的文件部分。<br />
首先运行<code>flow</code>，此时会启动flow server，并展示当前所有文件的错误。当修改了文件之后，再次运行<code>flow</code>，即可展示最新的错误列表。<br />
相比<code>flow check</code>，flow server省去了每次检查全部项目文件的开销，也可以更好地与IDE工具结合。<br />
当不需要flow server时，运行<code>flow stop</code>即可关闭。</p>
<h4>持续集成</h4>
<p>既然使用了flow做代码检查，自然也希望在构建工具中添加flow检查的步骤。grunt和gulp都有对应的flow插件。<br />
也可以在package.json声明依赖，直接<code>npm run [task]</code>运行。由于flow是用<a href="http://ocaml.org/" target="_blank">OCaml</a>语言写的，npm上只有对应的二进制包。<br />
<code>npm install flow-bin</code></p>
<h4>Windows</h4>
<p>目前flow暂时没有windows的支持，不过最近官方貌似在<a href="https://github.com/facebook/flow/issues/6" target="_blank">issues</a>宣布开始准备支持了。所以耐心等待吧~</p>
<h3>结语</h3>
<p>对于js越来越复杂的应用场景，类型检查的优势也渐渐凸显。flow的目标是通过一点点代码的改动就发现文件中的类型错误，功能上确实很强大。<br />
本文仅是flow工具的简单介绍，更多使用帮助请戳<a href="//flowtype.org/docs/getting-started.html" target="_blank">http://flowtype.org/docs/getting-started.html</a></p>
<p>参考文档：<a href="http://flowtype.org/docs/getting-started.html">http://flowtype.org/docs/getting-started.html</a><br />
<a href="https://code.facebook.com/posts/1505962329687926/flow-a-new-static-type-checker-for-javascript/">https://code.facebook.com/posts/1505962329687926/flow-a-new-static-type-checker-for-javascript/</a></p>
</article>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/07/flow-a-static-type-checker-for-javascript-from-facebook/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
		<item>
		<title>前端逻辑和Node直出复用与重构</title>
		<link>http://www.alloyteam.com/2015/07/qian-duan-luo-ji-he-node-zhi-chu-fu-yong-yu-zhong-gou-2/</link>
		<comments>http://www.alloyteam.com/2015/07/qian-duan-luo-ji-he-node-zhi-chu-fu-yong-yu-zhong-gou-2/#comments</comments>
		<pubDate>Fri, 31 Jul 2015 13:36:28 +0000</pubDate>
		<dc:creator><![CDATA[burlin]]></dc:creator>
				<category><![CDATA[Node.js]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=8008</guid>
		<description><![CDATA[不得不聊到的重构简介 要实现软件演化基本准则，最关键的策略就是重构，Martin Fowler将其定义为”在不 [&#8230;]]]></description>
				<content:encoded><![CDATA[<h3 id="_1">不得不聊到的重构简介</h3>
<p>要实现软件演化基本准则，最关键的策略就是重构，Martin Fowler将其定义为”在不改版软件外部行为的前提下，对其内部结构进行改变，使之更容易理解并便于修改“。</p>
<h3 id="_2"><a class="headeranchor-link" href="#_2" name="user-content-_2"></a>复用的理由</h3>
<p>重复的代码，几乎是代表着对最初设计彻底分解方面的一个失误。无论何时，如果需要对某个地方进行修改，你都不得不在另一个地方进行完成同样的修改，这样你就陷入了两线作战的境地。重复的代码同样违背了代码哲学DRY原则：”Don’t Repeat Yourself“<br />
<span id="more-8008"></span></p>
<h3 id="_3"><a class="headeranchor-link" href="#_3" name="user-content-_3"></a>复用的例子</h3>
<p>举个例子，现在很多第三方库已经默认支持不同规范的引用，开放给第三方使用的组件能兼容不同的规范。然而很多时候如果我们引用第三方组件或者自己的组件时，并没有采用模块化开发抑或单一支持一种模块化，通常我们自己需要包装一下支持模块化引用依赖，如下示例：</p>
<p>使用seajs规范进行模块化加载，所以定义的模块都是以这样的形式加载，该模块c依赖a,b</p><pre class="crayon-plain-tag">define(['./a', './b'], function (require, exports, module) {
        // dosometing
    });</pre><p>那么，在服务器做node直出的时候，如何使用同一个文件进行复用呢</p><pre class="crayon-plain-tag">;(function (root, factory) {
    if (typeof module === 'object' &amp;&amp; typeof module.exports === 'object') {
        var a = require('./a');
        var b = require('./b');
        module.exports = factory(root);
        return;
    };
    if (typeof define === 'function' &amp;&amp; (define.amd || define.cmd)) {
        define(['./a', './b'], function (require, exports, module) {
            var a = require('a');
            var b = require('b');
            return factory(root);
        });
    } else {
        root.c = factory(root);
    }
})(this, function (root) {
    // dosometing
});</pre><p>这里会有个立即调用的匿名函数，判断模块加载器的类型，采用不同的模块化定义规范，如果没有的话，就直接暴露在全局。</p>
<h3 id="_4"><a class="headeranchor-link" href="#_4" name="user-content-_4"></a>重构的例子</h3>
<p>由于Node直出只需要获取处理数据，并把数据渲染在模板上，返回html字符串即可。<br />
这就需要我们抽离Model，Controller<br />
重构，这里就举个简单例子了</p><pre class="crayon-plain-tag">var model = new Model({
    cgi: "/cgi-bin/bottom_info",
    param: {
        a: 1
    },
    renderer: function(data){
        handle(data);
        tmpl(data);
    }
}</pre><p>然后注入NodeOut状态变量来标注是否直出，然后做相应的兼容，例如client端数据需要更新page，不再拉取本地缓存或者线上数据。</p>
<p>node端</p><pre class="crayon-plain-tag">res.body += ('&lt;script&gt;var NodeOut=true;');
res.body += ('&lt;/script&gt;');</pre><p>浏览器端</p><pre class="crayon-plain-tag">if (typeof nodeOut !== 'undefined') {
    //事件绑定
    EventBind();
    //不再拉取数据
    return;
}</pre><p></p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/07/qian-duan-luo-ji-he-node-zhi-chu-fu-yong-yu-zhong-gou-2/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>使用Abstract 2.0构建页面</title>
		<link>http://www.alloyteam.com/2015/07/shi-yong-abstract-2-0-gou-jian-ye-mian/</link>
		<comments>http://www.alloyteam.com/2015/07/shi-yong-abstract-2-0-gou-jian-ye-mian/#comments</comments>
		<pubDate>Fri, 31 Jul 2015 12:57:57 +0000</pubDate>
		<dc:creator><![CDATA[TAT.dorsywang]]></dc:creator>
				<category><![CDATA[Web开发]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=7984</guid>
		<description><![CDATA[为什么是2.0? Abstract 1.0去哪了？1.0就在这里 Abstract 1.0并非凭空产生，而是来 [&#8230;]]]></description>
				<content:encoded><![CDATA[<h2>为什么是2.0?</h2>
<p>Abstract 1.0去哪了？1.0就在这里<br />
<span id="more-7984"></span><br />
<a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/9D091902EEDCF30CC954521638883510.png"><img src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/9D091902EEDCF30CC954521638883510.png" style="width: 320px;height: 568px;" alt="9D091902EEDCF30CC954521638883510" width="320" height="568" class="alignnone size-full wp-image-7987" /></a><br />
Abstract 1.0并非凭空产生，而是来自兴趣部落这样千万级访问量大型项目的最佳实践，经过了千万客户端的检验，也证明了Abstract是一款优秀的框架。</p>
<h2>Abstract 2.0是否是轮子？</h2>
<p>用过Abstract的同学都知道答案是否定的，就拿当下最流行的框架来举例，使用了AngularJS、React之后，是否就可以不用Abstract了，答案也是否定的，Abstract解决的问题的层面是高于AngularJS和React的，在抽象层面上Abstract更高于AngularJS、React。更为简单的叙述是，AngularJS、React会帮你写业务逻辑么？肯定不会，但Abstract会帮你写业务逻辑，这就是Abstract和其他框架的区别所在.<br />
如果React宣称自己处于抽象层面的V(view)层，那么Abstract是处于C(controller)层的框架</p>
<h2>Abstract为兴趣部落这样大型的项目解决了什么问题？</h2>
<p>Abstract带来的优势是很可观的</p>
<ul>
<li>统一风格的代码</li>
<li>清晰的逻辑</li>
<li>解决代码复用与耦合的问题</li>
<li>快速开发页面</li>
</ul>
<h2>
Abstract 怎么去构建页面？<br />
</h2>
<p>我们来做一个对比，看普通的写法是怎么做的，用Abstract是怎么做的</p>
<p>假设我们来完成部落头部的信息的渲染，普通的写法可能是这样的</p><pre class="crayon-plain-tag">var renderTop = function(){
    // 请求cgi
    $.ajax({
       url: "/cgi-bin/top_info",
       data: {
           bid: 10038
       },
       success: function(data){
            for(var i = 0; i < data.posts.length; i ++){
               var item = data.posts[i];
               item.flag = getFlag(item.flag);
            }
            
            // 渲染模板了
            Tmpl(topTmpl, data).appendTo($("#top"));
       },

       error: function(data){
       }
    });
};

renderTop();</pre><p></p>
<p> 这么简单的逻辑，感觉写起来还不错</p>
<p>看看使用Abstract是怎么做的</p><pre class="crayon-plain-tag">var topInfo = new RenderModel({
     cgiName: "/cgi-bin/top_info",
     param: {
          bid: 10038
     },
     renderTmpl: topTmpl,
     renderContainer: $("#top"),
     processData: function(data){
          for(var i = 0; i < data.posts.length; i ++){
               var item = data.posts[i];
               item.flag = getFlag(item.flag);
          }          
     }
});

topInfo.rock();</pre><p>哈，感觉没什么高大上的，也没什么吧。。。这还不是Abstract强大之处</p>
<p>现在需求来了，产品要求加快top渲染的速度，怎么办？有什么办法？</p>
<p>一个办法就是做本地缓存，一进来使用上次请求过的据渲染，安份的写法应该是这样的吧</p><pre class="crayon-plain-tag">var renderTop = function(){
    //先使用缓存渲染数据
    var dataCache = JSON.parse(localStorage.getData("top") || '{}');
    Tmpl(topTmpl, dataCache).appendTo($("#top"));      

    // 请求cgi
    $.ajax({
       url: "/cgi-bin/top_info",
       data: {
           bid: 10038
       },
       success: function(data){
            for(var i = 0; i < data.posts.length; i ++){
               var item = data.posts[i];
               item.flag = getFlag(item.flag);
            }
            
            // 渲染模板了
            Tmpl(topTmpl, data).appendTo($("#top"));
            
            //写下缓存供下次使用
            // 防止写的时候溢出啊亲
            try{
                  localStorage.setData('top', JSON.stringify(data));
            }cache(e){
                   localStorage.clear();
                   localStorage.setData('top', JSON.stringify(data));
            }
       },

       error: function(data){
       } 
    });
}
renderTop();</pre><p>看起来也还不错，好像挺好的，这次，第二次之后进来，top刷刷就出来了，Abstract怎么写呢</p><pre class="crayon-plain-tag">/*
 Abstract构建的页面
*/
var topInfo = new RenderModel({
     cgiName: "/cgi-bin/top_info",
     param: {
          bid: 10038
     },
     renderTmpl: topTmpl,
     renderContainer: $("#top"),
     processData: function(data){
          for(var i = 0; i < data.posts.length; i ++){
               var item = data.posts[i];
               item.flag = getFlag(item.flag);
          }          
     }
});

topInfo.rock();</pre><p>看了半天，发现跟之前的写法没什么区别啊？是啊，使用Abstract你不需要关心缓存层的渲染的，它自动帮你做了。但有些时候我不需要它做，只需要加上noCache: false这样的选项关闭即可</p>
<p>这样感觉也没什么值得炫耀的功能，是的，但是，接定来看</p>
<p>接着我们可能要渲染底部的信息，普通是这么做的</p><pre class="crayon-plain-tag">var renderTop = function(){
    //先使用缓存渲染数据
    var dataCache = JSON.parse(localStorage.getData("top") || '{}');
    Tmpl(topTmpl, dataCache).appendTo($("#top"));      

    // 请求cgi
    $.ajax({
       url: "/cgi-bin/top_info",
       data: {
           bid: 10038
       },
       success: function(data){
            for(var i = 0; i < data.posts.length; i ++){
               var item = data.posts[i];
               item.flag = getFlag(item.flag);
            }
            
            // 渲染模板了
            Tmpl(topTmpl, data).appendTo($("#top"));
            
            //写下缓存供下次使用
            // 防止写的时候溢出啊亲
            try{
                  localStorage.setData('top', JSON.stringify(data));
            }cache(e){
                   localStorage.clear();
                   localStorage.setData('top', JSON.stringify(data));
            }
       },

       error: function(data){
       }
    });
};

var renderBottom = function(){
    //先使用缓存渲染数据
    var dataCache = JSON.parse(localStorage.getData("bottom") || '{}');
    Tmpl(topTmpl, dataCache).appendTo($("#bottom"));      

    // 请求cgi
    $.ajax({
       url: "/cgi-bin/bottom_info",
       data: {
           bid: 10038
       },
       success: function(data){
            for(var i = 0; i < data.posts.length; i ++){
               var item = data.posts[i];
               item.flag = getFlag(item.flag);
            }
            
            // 渲染模板了
            Tmpl(bottomTmpl, data).appendTo($("#bottom"));
            
            //写下缓存供下次使用
            // 防止写的时候溢出啊亲
            try{
                  localStorage.setData('bottom', JSON.stringify(data));
            }cache(e){
                   localStorage.clear();
                   localStorage.setData('bottom', JSON.stringify(data));
            }
       },

       error: function(data){
       }
    });
};

renderTop();
renderBottom();</pre><p>这样写或许也挺简单的，但是不同的人有不同的写法，可能一个renderTop和一个renderBottom写法就不同，更别说更加复杂的逻辑，那Abstract怎么写</p><pre class="crayon-plain-tag">/*
 Abstract构建的页面
*/
var topInfo = new RenderModel({
     cgiName: "/cgi-bin/top_info",
     param: {
          bid: 10038
     },
     renderTmpl: topTmpl,
     renderContainer: $("#top"),
     processData: function(data){
          for(var i = 0; i < data.posts.length; i ++){
               var item = data.posts[i];
               item.flag = getFlag(item.flag);
          }          
     }
});

var bottomInfo = new RenderModel({
     cgiName: "/cgi-bin/bottom_info",
     param: {
          bid: 10038
     },
     renderTmpl: bottomTmpl,
     renderContainer: $("#bottom"),
     processData: function(data){
          for(var i = 0; i < data.posts.length; i ++){
               var item = data.posts[i];
               item.flag = getFlag(item.flag);
          }          
     }
});

var page = new PageMode();
page.add(topInfo);
page.add(bottomInfo);
page.rock();</pre><p>细心的同学会发现，Abstract在最后，不是让topInfo和bottomInfo分别rock，而上加到了一个pageModel的实例上，让pageModel实例去rock。</p>
<p>可以看出，Abstract的优点</p>
<p>1.规范化代码，所有人的代码风格统一，阅读方便</p>
<p>2.写法简单，快速</p>
<p>3.尽可能多的帮业务开发者做更多的事情</p>
<p>4.页面模块化的思想与配置型代码（类似React，但那时不了解有React)</p>
<p>5.更优雅的代码</p>
<p>上面的例子还不足矣让Abstract来支撑更复杂的页面，那如果更复杂页面怎么写？</p>
<p>移动中比较常见的场景就是滚动加载，这时用Abstract要怎么写呢？</p>
<p>普通的写法，可能要洋洋洒洒写上一大篇了吧，Abstract是这样写的</p><pre class="crayon-plain-tag">/*
 Abstract构建的页面
*/
var topInfo = new RenderModel({
     cgiName: "/cgi-bin/top_info",
     param: {
          bid: 10038
     },
     renderTmpl: topTmpl,
     renderContainer: $("#top"),
     processData: function(data){
          for(var i = 0; i < data.posts.length; i ++){
               var item = data.posts[i];
               item.flag = getFlag(item.flag);
          }          
     }
});

var bottomInfo = new RenderModel({
     cgiName: "/cgi-bin/bottom_info",
     param: {
          bid: 10038
     },
     renderTmpl: bottomTmpl,
     renderContainer: $("#bottom"),
     processData: function(data){
          for(var i = 0; i < data.posts.length; i ++){
               var item = data.posts[i];
               item.flag = getFlag(item.flag);
          }          
     }
});

// 这里是一个滚动加载模型
var postList = new ScrollModel({
     cgiName: "/cgi-bin/posts",
     param: function(){
          var every = 10;
          var start = - every;
          return function(){
              return {
                  start: start += every,
                  num: every,
                  bid: 10038
              };
          };
     }(),
     renderTmpl: postTmpl,
     renderContainer: $("#postList"),
     processData: function(data){
          for(var i = 0; i < data.posts.length; i ++){
               var item = data.posts[i];
               item.flag = getFlag(item.flag);
          }          
     }
});

var page = new PageMode();
page.add(topInfo);
page.add(bottomInfo);
page.add(postList);
page.rock();</pre><p>就这么简单，一个简单的页面就完成了</p>
<h2>Abstract 2.0的地址</h2>
<p><a href="http://alloyteam.github.io/Abstract.js/">点击这里访问更多信息吧</a></p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/07/shi-yong-abstract-2-0-gou-jian-ye-mian/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
		</item>
		<item>
		<title>react组件间通信</title>
		<link>http://www.alloyteam.com/2015/07/react-zu-jian-jian-tong-xin/</link>
		<comments>http://www.alloyteam.com/2015/07/react-zu-jian-jian-tong-xin/#comments</comments>
		<pubDate>Thu, 30 Jul 2015 04:25:32 +0000</pubDate>
		<dc:creator><![CDATA[TAT.Fujun]]></dc:creator>
				<category><![CDATA[Web开发]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=7958</guid>
		<description><![CDATA[通信是发送者通过某种媒体以某种格式来传递信息到收信者以达致某个目的（摘至维基百科）。 前两天为了练习react [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>通信是发送者通过某种媒体以某种格式来传递信息到收信者以达致某个目的（摘至维基百科）。</p>
<p>前两天为了练习react，自己写了如下一个Demo，功能很简单，展示学生成绩列表，支持按性别和姓名筛选。效果如下：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/demo1.gif"><img class="alignnone  wp-image-7960" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/demo1.gif" alt="demo1" width="648" height="735" /></a></p>
<p>从上面的效果图，我们也可以看到如下的组件树结构：</p>
<p><span id="more-7958"></span><br />
<a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/structure.png"><img class="alignnone  wp-image-7972" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/structure.png" alt="structure" width="594" height="296" /></a></p>
<p>StudentScoreTable有三个子组件：GenderFilter, NameFilter, ScoreTable。其中，ScoreTable又包含若干个子组件ScoreItem。从功能上，我们知道：</p>
<ol>
<li>当选择性别后，要对ScoreItem做筛选</li>
<li>当输入姓名后，要对ScoreItem做筛选</li>
<li>当同时选择性别，输入姓名，两个筛选条件对ScoreItem生效</li>
<li>点击某ScoreItem的删除按钮后，删除此ScoreItem</li>
</ol>
<p>也就是说：</p>
<ol>
<li>当GenderFilter发生改变（change）时，ScoreItem要能感知到这个变化并做出相应反馈（进行筛选）</li>
<li>当NameFilter发生改变时，ScoreItem也要能感知这个变化并做出相应反馈</li>
<li>当某ScoreItem删除后，可能StudentScoreTable, GenderFilter, NameFilter要做出相应反馈，即以后筛选，少了一个ScoreItem</li>
</ol>
<p>下面是我的第一版本实现</p><pre class="crayon-plain-tag">// 测试数据
var _score = [
    {name: '张三', gender: '男', chinese: 85, math: 98, _id:0},
    {name: '张三', gender: '女', chinese: 95, math: 90, _id:1},
    {name: '李四', gender: '男', chinese: 65, math: 48, _id:2},
    {name: '大妹', gender: '女', chinese: 95, math: 100, _id:3},
    {name: '王五', gender: '男', chinese: 75, math: 88, _id:4},
    {name: '赵钱', gender: '男', chinese: 75, math: 98, _id:5},
    {name: '二妹', gender: '女', chinese: 90, math: 98, _id:6}
];

var StudentScoreTable = React.createClass({
    getInitialState: function () {
        return {
            genderFilter: 0,
            nameFilter: '',
            data: _score,
            modifyScore: null,
            className: 'dialog modify'
        }
    },
    onGenderChange: function (gender) {
        this.setState({genderFilter: gender});
    },
    onDeleteScoreItem: function (id) {
        var data = this.state.data.map(function (item) {
            if(item._id === id) {
                item.deleteFlag = true;
            }
            return item;
        });

        this.setState(data, data);
    },
    onNameChange: function (name) {
        this.setState({nameFilter: name});
    },
    render: function () {
        return (
            &lt;div&gt;
               &lt;GenderFilter onGenderChange={this.onGenderChange} genderFilter={this.state.genderFilter}/&gt;
               &lt;NameFilter onNameChange={this.onNameChange} nameFilter={this.state.nameFilter}/&gt;
               &lt;ScoreTable
                    scoreNotes={this.state.data}
                    genderFilter={this.state.genderFilter}
                    nameFilter={this.state.nameFilter}
                    deleteScoreItem={this.onDeleteScoreItem}
                    modifyItem={this.onModify}
               /&gt;
           &lt;/div&gt;
        );
    }
});

var GenderFilter = React.createClass({
    genderChangeHandler: function () {
        this.props.onGenderChange(this.refs.genderFilter.getDOMNode().value);
    },
    render: function () {
        return (
            &lt;div className="condition-item"&gt;
                &lt;label&gt;
                    &lt;span&gt;按性别筛选&lt;/span&gt;
                    &lt;select onChange={this.genderChangeHandler} ref="genderFilter"&gt;
                        &lt;option value="0"&gt;All&lt;/option&gt;
                        &lt;option value="1"&gt;男生&lt;/option&gt;
                        &lt;option value="2"&gt;女生&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/label&gt;
            &lt;/div&gt;
            );
    }
});

var NameFilter = React.createClass({
    nameChangeHandler: function () {
        this.props.onNameChange(this.refs.nameFilter.getDOMNode().value);
    },
    render: function () {
        return (
            &lt;div className="condition-item"&gt;
                &lt;label&gt;
                    &lt;span&gt;按姓名筛选&lt;/span&gt;
                    &lt;input type="text" ref="nameFilter" onChange={this.nameChangeHandler} value={this.props.nameFilter}/&gt;
                &lt;/label&gt;
            &lt;/div&gt;
            );
    }
});

var ScoreTable = React.createClass({
    deleteItemHandler: function (id) {
        this.props.deleteScoreItem(id);
    },
    modifyItem: function (id) {
        this.props.modifyItem(id);
    },
    render: function () {
        var scoreNotes = [];
        var genderFilter = +this.props.genderFilter,
            nameFilter = this.props.nameFilter,
            GENDER = ['', '男', '女'],
            _this = this;

        this.props.scoreNotes.map(function (scoreItem) {
            if (genderFilter !== 0 &amp;&amp; nameFilter === '') {
                // 仅genderfilter生效
                if (GENDER[genderFilter] === scoreItem.gender) {
                    !scoreItem.deleteFlag &amp;&amp; scoreNotes.push(&lt;ScoreItem score={scoreItem} onDelete={_this.deleteItemHandler} onModify={_this.modifyItem}/&gt;);
                }
                return;
            }

            if (genderFilter === 0 &amp;&amp; nameFilter !== '') {
                // 仅nameFilter生效
                if (scoreItem.name === nameFilter) {
                    !scoreItem.deleteFlag &amp;&amp; scoreNotes.push(&lt;ScoreItem score={scoreItem} onDelete={_this.deleteItemHandler} onModify={_this.modifyItem}/&gt;);
                }
                return;
            }

            if (genderFilter !== 0 &amp;&amp; nameFilter !== '') {
                // 两个filter都生效
                if (GENDER[genderFilter] === scoreItem.gender &amp;&amp; scoreItem.name === nameFilter) {
                    !scoreItem.deleteFlag &amp;&amp; scoreNotes.push(&lt;ScoreItem score={scoreItem} onDelete={_this.deleteItemHandler} onModify={_this.modifyItem}/&gt;);
                }
                return;
            }

            !scoreItem.deleteFlag &amp;&amp; scoreNotes.push(&lt;ScoreItem score={scoreItem} onDelete={_this.deleteItemHandler} onModify={_this.modifyItem}/&gt;);
        });

        return (
            &lt;table&gt;
                &lt;thead&gt;
                    &lt;tr&gt;
                        &lt;th&gt;姓名&lt;/th&gt;
                        &lt;th&gt;性别&lt;/th&gt;
                        &lt;th&gt;语文&lt;/th&gt;
                        &lt;th&gt;数学&lt;/th&gt;
                        &lt;th&gt;操作&lt;/th&gt;
                    &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody&gt;
                    {scoreNotes}
                &lt;/tbody&gt;
            &lt;/table&gt;
            );
    }
});

var ScoreItem = React.createClass({
    deleteHandler: function (e, id) {
        this.props.onDelete(this.props.score._id);
    },
    modifyHandler: function () {
        this.props.onModify(this.props.score._id);
    },
    render: function () {
        var score = this.props.score;

        return (
            &lt;tr&gt;
                &lt;td&gt;{score.name}&lt;/td&gt;
                &lt;td&gt;{score.gender}&lt;/td&gt;
                &lt;td&gt;{score.chinese}&lt;/td&gt;
                &lt;td&gt;{score.math}&lt;/td&gt;
                &lt;td&gt;&lt;span className="trigger" onClick={this.modifyHandler}&gt;修改&lt;/span&gt;&lt;span className="trigger" onClick={this.deleteHandler}&gt;删除&lt;/span&gt;&lt;/td&gt;
            &lt;/tr&gt;
            );
    }
});

React.render(&lt;StudentScoreTable /&gt;, document.querySelector('.j-score'));</pre><p>当然，功能都是实现了。但我却感觉非常不舒服。首先，让我们来看看数据在这些组件间是怎么通信的（数据怎么在这些组件间传递的）。StudentScoreTable拥有数据模型，由于这些数据会变，所以使用state储存。为了让数据能够传到其子组件，使用了props，如：</p><pre class="crayon-plain-tag">&lt;div&gt;
               &lt;GenderFilter onGenderChange={this.onGenderChange} genderFilter={this.state.genderFilter}/&gt;
               &lt;NameFilter onNameChange={this.onNameChange} nameFilter={this.state.nameFilter}/&gt;
               &lt;ScoreTable
                    scoreNotes={this.state.data}
                    genderFilter={this.state.genderFilter}
                    nameFilter={this.state.nameFilter}
                    deleteScoreItem={this.onDeleteScoreItem}
                    modifyItem={this.onModify}
               /&gt;
           &lt;/div&gt;</pre><p>再往下看，就会知道，整个数据从StudentScoreTable到其包含的组件，都是使用props一层一层传下去的。当ScoreItem删除时，为了使用StudentScoreTable能够感知到，还利用props建立了一个事件传递链接：</p>
<p>ScoreItem的click事件，调用其本身的deleteHandler -&gt;ScoreTable的onDelete –&gt;ScoreTable自身的deleteItemHandler –&gt; StudentScoreTable的deleteItem –&gt; StudentScoreTable的onDeleteScoreItem，更新state，完成ScoreItem的删除</p>
<p>从上面的数据，事件传递链，可以看出，都是一层一层传递，为了建立数据或事件的通信链，写了很多没用的props属性。这还不是问题的关键，毕竟这里只有三级组件嵌套，如果有6级，10级呢？很显示，再这样一层一层地进行组件通信，是不可行的。</p>
<p>那么有没有一种方法，可以跨级调用组件的方法呢？比如可以直接通过ScoreItem直接调用StudentScoreTable的方法，让其更新其state，这样就可以省掉中间的ScoreTable组件。在同事的提醒下，有了第二版实现：</p><pre class="crayon-plain-tag">// 测试数据
var _score = 略;

var StudentScoreTable,
    GenderFilter,
    NameFilter,
    ScoreTable,
    ScoreItem,
    _StudentScoreTable,
    _GenderFilter,
    _NameFilter,
    _ScoreItem;

StudentScoreTable = React.createClass({
    getInitialState: function () {
        _StudentScoreTable = this; // 把StudentScoreTable组件赋值给一个变量，以便在其它组件中可以使用此组件的方法
        return {
            genderFilter: 0,
            nameFilter: '',
            data: _score,
            modifyScore: null,
            className: 'dialog modify'
        }
    },
    onGenderChange: function (gender) {
        this.setState({genderFilter: gender});
    },
    onDeleteScoreItem: function (id) {
        var data = this.state.data.map(function (item) {
            if(item._id === id) {
                item.deleteFlag = true;
            }
            return item;
        });

        this.setState(data, data);
    },
    onNameChange: function (name) {
        this.setState({nameFilter: name});
    },
    render: function () {
        return (
            &lt;div&gt;
               &lt;GenderFilter genderFilter={this.state.genderFilter}/&gt;
               &lt;NameFilter nameFilter={this.state.nameFilter}/&gt;
               &lt;ScoreTable scoreNotes={this.state.data} /&gt;
           &lt;/div&gt;
        );
    }
});

GenderFilter = React.createClass({
    getInitialState: function () {
        _GenderFilter = this;
        return null;
    },
    genderChangeHandler: function () {
        _StudentScoreTable.onGenderChange(this.refs.genderFilter.getDOMNode().value);
    },
    render: function () {
        return (
            &lt;div className="condition-item"&gt;
                &lt;label&gt;
                    &lt;span&gt;按性别筛选&lt;/span&gt;
                    &lt;select onChange={this.genderChangeHandler} ref="genderFilter"&gt;
                        &lt;option value="0"&gt;All&lt;/option&gt;
                        &lt;option value="1"&gt;男生&lt;/option&gt;
                        &lt;option value="2"&gt;女生&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/label&gt;
            &lt;/div&gt;
            );
    }
});

NameFilter = React.createClass({
    getInitialState: function () {
        _NameFilter = this;
        return null;
    },
    nameChangeHandler: function () {
        _StudentScoreTable.onNameChange(this.refs.nameFilter.getDOMNode().value);
    },
    render: function () {
        return (
            &lt;div className="condition-item"&gt;
                &lt;label&gt;
                    &lt;span&gt;按姓名筛选&lt;/span&gt;
                    &lt;input type="text" ref="nameFilter" onChange={this.nameChangeHandler} value={this.props.nameFilter}/&gt;
                &lt;/label&gt;
            &lt;/div&gt;
            );
    }
});

ScoreTable = React.createClass({
    render: function () {
        var scoreNotes = [];
        var genderFilter = +_StudentScoreTable.state.genderFilter,
            nameFilter = _StudentScoreTable.state.nameFilter,
            GENDER = ['', '男', '女'],
            _this = this;

        this.props.scoreNotes.map(function (scoreItem) {
            if (genderFilter !== 0 &amp;&amp; nameFilter === '') {
                // 仅genderfilter生效
                if (GENDER[genderFilter] === scoreItem.gender) {
                    !scoreItem.deleteFlag &amp;&amp; scoreNotes.push(&lt;ScoreItem score={scoreItem} /&gt;);
                }
                return;
            }

            if (genderFilter === 0 &amp;&amp; nameFilter !== '') {
                // 仅nameFilter生效
                if (scoreItem.name === nameFilter) {
                    !scoreItem.deleteFlag &amp;&amp; scoreNotes.push(&lt;ScoreItem score={scoreItem} /&gt;);
                }
                return;
            }

            if (genderFilter !== 0 &amp;&amp; nameFilter !== '') {
                // 两个filter都生效
                if (GENDER[genderFilter] === scoreItem.gender &amp;&amp; scoreItem.name === nameFilter) {
                    !scoreItem.deleteFlag &amp;&amp; scoreNotes.push(&lt;ScoreItem score={scoreItem} /&gt;);
                }
                return;
            }

            !scoreItem.deleteFlag &amp;&amp; scoreNotes.push(&lt;ScoreItem score={scoreItem} /&gt;);
        });

        return (
            &lt;table&gt;
                &lt;thead&gt;
                    &lt;tr&gt;
                        &lt;th&gt;姓名&lt;/th&gt;
                        &lt;th&gt;性别&lt;/th&gt;
                        &lt;th&gt;语文&lt;/th&gt;
                        &lt;th&gt;数学&lt;/th&gt;
                        &lt;th&gt;操作&lt;/th&gt;
                    &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody&gt;
                    {scoreNotes}
                &lt;/tbody&gt;
            &lt;/table&gt;
            );
    }
});

ScoreItem = React.createClass({
    getInitialState: function () {
        _ScoreItem = this;
        return null;
    },
    deleteHandler: function (e, id) {
        _StudentScoreTable.onDeleteScoreItem(this.props.score._id);
    },
    render: function () {
        var score = this.props.score;

        return (
            &lt;tr&gt;
                &lt;td&gt;{score.name}&lt;/td&gt;
                &lt;td&gt;{score.gender}&lt;/td&gt;
                &lt;td&gt;{score.chinese}&lt;/td&gt;
                &lt;td&gt;{score.math}&lt;/td&gt;
                &lt;td&gt;&lt;span className="trigger"&gt;修改&lt;/span&gt;&lt;span className="trigger" onClick={this.deleteHandler}&gt;删除&lt;/span&gt;&lt;/td&gt;
            &lt;/tr&gt;
            );
    }
});

React.render(&lt;StudentScoreTable /&gt;, document.querySelector('.j-score'));</pre><p>这主要的变化就是要通信的两个组件，直接通过其组件句柄去直接访问其方法，没有了中间环节，代码也简洁了很多。</p>
<p>React的官网上有这样一段话：</p>
<p>For communication between two components that don&#8217;t have a parent-child relationship, you can set up your own global event system. Subscribe to events in componentDidMount(), unsubscribe in componentWillUnmount(), and call setState() when you receive an event.</p>
<p>大意就是说，可以使用观察者模式来解决组件间的通信。在这之上，学生成绩表的第三个版本出来了(得先实现一个PubSub，网上有很多，随便找一个)：</p><pre class="crayon-plain-tag">// 测试数据
var _score = 略;

var StudentScoreTable,
    _StudentScoreTable,
    GenderFilter,
    NameFilter,
    ScoreTable,
    ScoreItem,
    ScoreItemDeleteEvt = 'scoreitem delete event',
    GenderFilterChangeEvt = 'genderFilter change event',
    NameFilterChangeEvt = 'nameFilter change event';

StudentScoreTable = React.createClass({
    getInitialState: function () {
        _StudentScoreTable = this;
        return {
            genderFilter: 0,
            nameFilter: '',
            data: _score,
            modifyScore: null,
            className: 'dialog modify'
        }
    },
    componentDidMount: function () {
        // 订阅ScoreItem的删除事件
        PubSub.subscribe(ScoreItemDeleteEvt, this.onDeleteScoreItem);

        // 订阅GenderFilter的改变事件
        PubSub.subscribe(GenderFilterChangeEvt, this.onGenderChange);

        // 订阅NameFilter的改变事件
        PubSub.subscribe(NameFilterChangeEvt, this.onNameChange);

    },
    onGenderChange: function (gender) {
        this.setState({genderFilter: gender});
    },
    onDeleteScoreItem: function (id) {
        var data = this.state.data.map(function (item) {
            if(item._id === id) {
                item.deleteFlag = true;
            }
            return item;
        });

        this.setState(data, data);
    },
    onNameChange: function (name) {
        this.setState({nameFilter: name});
    },
    render: function () {
        return (
            &lt;div&gt;
               &lt;GenderFilter genderFilter={this.state.genderFilter}/&gt;
               &lt;NameFilter nameFilter={this.state.nameFilter}/&gt;
               &lt;ScoreTable scoreNotes={this.state.data} /&gt;
           &lt;/div&gt;
        );
    }
});

GenderFilter = React.createClass({
    genderChangeHandler: function () {
        // 发布GenderChange事件
        PubSub.publish(GenderFilterChangeEvt, this.refs.genderFilter.getDOMNode().value);
    },
    render: function () {
        return (
            &lt;div className="condition-item"&gt;
                &lt;label&gt;
                    &lt;span&gt;按性别筛选&lt;/span&gt;
                    &lt;select onChange={this.genderChangeHandler} ref="genderFilter"&gt;
                        &lt;option value="0"&gt;All&lt;/option&gt;
                        &lt;option value="1"&gt;男生&lt;/option&gt;
                        &lt;option value="2"&gt;女生&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/label&gt;
            &lt;/div&gt;
            );
    }
});

NameFilter = React.createClass({
    nameChangeHandler: function () {
        PubSub.publish(NameFilterChangeEvt, this.refs.nameFilter.getDOMNode().value);
    },
    render: function () {
        return (
            &lt;div className="condition-item"&gt;
                &lt;label&gt;
                    &lt;span&gt;按姓名筛选&lt;/span&gt;
                    &lt;input type="text" ref="nameFilter" onChange={this.nameChangeHandler} value={this.props.nameFilter}/&gt;
                &lt;/label&gt;
            &lt;/div&gt;
            );
    }
});

ScoreTable = React.createClass({
    render: function () {
        var scoreNotes = [];
        var genderFilter = +_StudentScoreTable.state.genderFilter,
            nameFilter = _StudentScoreTable.state.nameFilter,
            GENDER = ['', '男', '女'],
            _this = this;

        this.props.scoreNotes.map(function (scoreItem) {
            if (genderFilter !== 0 &amp;&amp; nameFilter === '') {
                // 仅genderfilter生效
                if (GENDER[genderFilter] === scoreItem.gender) {
                    !scoreItem.deleteFlag &amp;&amp; scoreNotes.push(&lt;ScoreItem score={scoreItem} /&gt;);
                }
                return;
            }

            if (genderFilter === 0 &amp;&amp; nameFilter !== '') {
                // 仅nameFilter生效
                if (scoreItem.name === nameFilter) {
                    !scoreItem.deleteFlag &amp;&amp; scoreNotes.push(&lt;ScoreItem score={scoreItem} /&gt;);
                }
                return;
            }

            if (genderFilter !== 0 &amp;&amp; nameFilter !== '') {
                // 两个filter都生效
                if (GENDER[genderFilter] === scoreItem.gender &amp;&amp; scoreItem.name === nameFilter) {
                    !scoreItem.deleteFlag &amp;&amp; scoreNotes.push(&lt;ScoreItem score={scoreItem} /&gt;);
                }
                return;
            }

            !scoreItem.deleteFlag &amp;&amp; scoreNotes.push(&lt;ScoreItem score={scoreItem} /&gt;);
        });

        return (
            &lt;table&gt;
                &lt;thead&gt;
                    &lt;tr&gt;
                        &lt;th&gt;姓名&lt;/th&gt;
                        &lt;th&gt;性别&lt;/th&gt;
                        &lt;th&gt;语文&lt;/th&gt;
                        &lt;th&gt;数学&lt;/th&gt;
                        &lt;th&gt;操作&lt;/th&gt;
                    &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody&gt;
                    {scoreNotes}
                &lt;/tbody&gt;
            &lt;/table&gt;
            );
    }
});

ScoreItem = React.createClass({
    deleteHandler: function (e, id) {
        PubSub.publish(ScoreItemDeleteEvt, this.props.score._id);
    },
    render: function () {
        var score = this.props.score;

        return (
            &lt;tr&gt;
                &lt;td&gt;{score.name}&lt;/td&gt;
                &lt;td&gt;{score.gender}&lt;/td&gt;
                &lt;td&gt;{score.chinese}&lt;/td&gt;
                &lt;td&gt;{score.math}&lt;/td&gt;
                &lt;td&gt;&lt;span className="trigger"&gt;修改&lt;/span&gt;&lt;span className="trigger" onClick={this.deleteHandler}&gt;删除&lt;/span&gt;&lt;/td&gt;
            &lt;/tr&gt;
            );
    }
});

React.render(&lt;StudentScoreTable /&gt;, document.querySelector('.j-score'));</pre><p>在使用PubSub后，代码就更清晰明了，而且大家都知道，PubSub有助于解藕，这非常有助于组织代码结构。</p>
<p><strong>小结：</strong></p>
<p>本文通过一个实际小例子讨论了React中组件通信的三种方法：</p>
<ol>
<li>使用props，构建通信链</li>
<li>在组件初始化的时候，保存组件的句柄，在其它组件中，使用此句柄达到直接访问组件的目的，完成通信</li>
<li>使用PubSub模式</li>
</ol>
<p>其中，第1种方式，在组件嵌套较深时，显示不适用。第2种在组件很多时，也得定义维护很多变量。相比之下，PubSub模式有助于解藕和代码组织，在React的组件通信时，推荐使用此方法。</p>
<p>最后，由于本人水平有限，也缺少React实战经验，有不严谨或不对的地方，还望大家指正。</p>
<p>附上源代码：http://share.weiyun.com/08ee52ccec9e21897d9f56ec0e62ec17</p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/07/react-zu-jian-jian-tong-xin/feed/</wfw:commentRss>
		<slash:comments>12</slash:comments>
		</item>
		<item>
		<title>是时候升级你的gulp到4.0了</title>
		<link>http://www.alloyteam.com/2015/07/update-your-gulp/</link>
		<comments>http://www.alloyteam.com/2015/07/update-your-gulp/#comments</comments>
		<pubDate>Wed, 29 Jul 2015 12:52:04 +0000</pubDate>
		<dc:creator><![CDATA[TAT.云中飞扬]]></dc:creator>
				<category><![CDATA[JavaScript]]></category>
		<category><![CDATA[Web 前端优化]]></category>
		<category><![CDATA[Web开发]]></category>
		<category><![CDATA[经验心得]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=7937</guid>
		<description><![CDATA[不得不说的废话 随着前端工程化的推进，相信越来越多的项目都用上了自动化构建。 对前端构建来说，使用最多的莫过于 [&#8230;]]]></description>
				<content:encoded><![CDATA[<article class="markdown-body entry-content">
<p align="center"><a href="http://gulpjs.com"><br />
<img style="max-width: 100%;" src="https://raw.githubusercontent.com/gulpjs/artwork/master/gulp-2x.png" alt="" /><br />
</a></p>
<h1><a id="user-content-不得不说的废话" class="anchor" href="#不得不说的废话"></a>不得不说的废话</h1>
<p>随着前端工程化的推进，相信越来越多的项目都用上了自动化构建。<br />
对前端构建来说，使用最多的莫过于<a href="http://gruntjs.com">grunt</a>和<a href="http://gulpjs.com">gulp</a>。</p>
<p>本文的主角是gulp，所以花一两句话来介绍gulp还是有必要的。</p>
<p>gulp是一款基于<a href="https://nodejs.org/api/stream.html">stream</a>的前端构建工具，由于底层使用stream，可以将多个任务无缝串连在一起，相比使用临时文件的grunt要快不少；同时也不用像grunt一样写一大堆配置文件，每一个任务都可以可编程的来完全控制逻辑。</p>
<p>gulp比grunt“快”这是公认的事实，这里不再过多比较两者之间的差异，还是那句话，各有千秋吧。</p>
<p><span id="more-7937"></span></p>
<h1><a id="user-content-gulp-40的变化" class="anchor" href="#gulp-40的变化"></a>gulp 4.0的变化</h1>
<p>扯完了废话，开始进入正题。<br />
gulp团队大概在两个月前提交了<a href="https://github.com/gulpjs/gulp/tree/4.0">4.0分支</a>，新版本带来了新的api，新api给任务流程控制带来了“革命性”的进步。<br />
但新版本并未提交到npm，可能现在连alpha都算不上吧，不过还是可以先进行体验的。</p>
<h3><a id="user-content-安装gulp-40" class="anchor" href="#安装gulp-40"></a>安装gulp 4.0</h3>
<p>想体验4.0只有通过github安装，执行以下两条命令即可在本地畅爽地使用gulp 4.0了。</p>
<p><code>npm install gulpjs/gulp#4.0 -g</code></p>
<p><code>npm install gulpjs/gulp#4.0 --save-dev</code></p>
<p>gulp 4.0相对以前的版本发生了不少变化</p>
<ol>
<li>使用新的任务系统<code>bach</code>，替换了老版本使用的<code>orchestrator</code></li>
</ol>
<p>也许会更快些？实际上gulp已经很快了，除非是超大型项目，否则几乎不用担心gulp构建会花太多时间，不过寻求更快总是好的。</p>
<ol>
<li>移除了gulp.task传递三参数的用法</li>
</ol>
<p>即这种用法将报错</p><pre class="crayon-plain-tag">gulp.task('watch', ['default'], function() {
    // TODO
    // watch file
});</pre><p>在gulp4.0之前，这种用法将会保证default任务先执行完再执行watch任务，gulp的任务流程控制就是这么实现的，不过这也是老版本gulp的弱点之一。</p>
<p>对我们这些普通使用者来说，最大的变化有两点</p>
<h3><a id="user-content-gulptask的变化" class="anchor" href="#gulptask的变化"></a><code>gulp.task</code>的变化</h3>
<p>gulp官方建议：</p>
<ol>
<li>当我们想在命令行通过敲<code>gulp taskname</code>的方式执行一个任务，这时候你应该使用<code>gulp.task</code>注册<code>taskName</code></li>
<li>当一个较复杂的任务（如dist）由很多个子任务组合而成的时候，子任务使用具名函数即可，不用单独为每个子任务进行注册，而只需将<code>dist</code>使用<code>gulp.task</code>进行注册，以前的版本则必须将每一个子任务都先使用<code>gulp.task</code>进行注册，然后再组合出<code>dist</code>，详细用法见最后的例子。</li>
</ol>
<p>gulp.task又增加了一种用法，即传递一个具名函数作为参数，将自动注册以该函数名命名的任务</p><pre class="crayon-plain-tag">function compile() {
    // TODO
    gulp.src('./src/*.js')
        .pipe(uglify())
        .pipe(gulp.dest('./dist/js'))
}
gulp.task(compile);</pre><p>等同于</p><pre class="crayon-plain-tag">gulp.task('compile', function() {
    // TODO
    gulp.src('./src/*.js')
        .pipe(uglify())
        .pipe(gulp.dest('./dist/js'))
});</pre><p>两者都可以通过命令行运行<code>gulp compile</code>执行任务</p>
<h3><a id="user-content-增加了gulpseries和gulpparallel" class="anchor" href="#增加了gulpseries和gulpparallel"></a>增加了<code>gulp.series</code>和<code>gulp.parallel</code></h3>
<p>哈哈，解放军来了。</p>
<p>如果你是gulp深度使用者，你一定不止一次吐槽过gulp的任务流程难以控制，就像一条复杂的电路一样，电路上很多电阻都是串联加并联的方式连接在一起，gulp一个复杂的任务同样也是由很多个子任务以串联（同步）加并联（异步）的方式连接在一起的。</p>
<p>老版本的gulp对多个异步任务很难控制，必须借助于第三方模块，如<code>run-sequence</code>、<code>event-stream</code>等，效果也并不理想。</p>
<p>现在gulp带来了两个新的api：<code>gulp.series</code>和<code>gulp.parallel</code>，这两个革命性的api将帮助开发者解决恼人的任务流程控制问题。</p>
<p>下面就来见识新api的神奇之处吧。</p>
<h3><a id="user-content-example" class="anchor" href="#example"></a>example</h3>
<p>以开发中最常见的dist任务为例，使用gulp首先得分解任务，dist大致分解成子任务如下</p>
<ol>
<li>删除开发目录dev，<code>clean-dev</code></li>
<li>删除发布目录dist，<code>clean-dist</code></li>
<li>合图并修改css中图片引用，<code>sprite</code></li>
<li>预编译css（如sass）到dev，<code>compile-css</code></li>
<li>预编译js到dev，<code>compile-js</code></li>
<li>从src拷贝html到dev，<code>copy-html</code></li>
<li>对dev下面的js/css进行md5，再拷贝到dist，<code>reversion</code></li>
<li>替换dev下html中js/css进行过md5之后的文件路径，并拷贝到dist，<code>replcae</code></li>
</ol>
<p>这只是一个普通的dist任务，我将dist拆得比较细并省略了压缩合并等常规任务，大致由以上8个步骤组成。</p>
<p>拆的粒度完全由自己控制，达到方便复用又便于理解的目的就行。</p>
<p>使用老版本的gulp，首先需要对每一个任务进行注册，这里只是为了说明问题，我省略了任务的具体代码。</p><pre class="crayon-plain-tag">gulp.task('clean-dev', function() {// TODO});
gulp.task('clean-dist', function() {// TODO});
gulp.task('sprite', function() {// TODO});
gulp.task('compile-css', function() {// TODO});
gulp.task('compile-js', function() {// TODO});
gulp.task('copy-html', function() {// TODO});
gulp.task('reversion', function() {// TODO});
gulp.task('replcae', function() {// TODO});</pre><p>然后，我们来理一理任务的流程，为了让任务执行效率更高，尽量保证能同时执行的都同时执行，这里简单画了个流程图来表示任务的流程，箭头表示先后顺序。</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/gulp4.0.png"><img style="max-width: 100%;" src="https://camo.githubusercontent.com/4fa1f9acdc1243aa3c5539435f1cefb11d3255cc/687474703a2f2f7777772e616c6c6f797465616d2e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031352f30372f67756c70342e302e706e67" alt="Task" data-canonical-src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/gulp4.0.png" /></a></p>
<p>可以看到图中既存在同步又存在异步的任务，需要实现这样的流程，我们还需要修改和注册额外的几个任务，并借助run-sequence等第三方模块。</p><pre class="crayon-plain-tag">gulp.task('compile-css', ['sprite']);
gulp.task('dev', ['clean-dev'], function() {
    runSecquence(['compile-css', 'compile-js', 'copy-html']);
});
gulp.task('md5', ['dev', 'clean-dist'], function() {
    runSecquence('reversion');
});
gulp.task('dist', ['md5'], function() {
    runSecquence('replcae');
});</pre><p>gulp官方推荐将任务最小化，每一个任务只做一件明确的事，可以看到任务拆得越细需要注册的任务就越多，为了处理同时涉及到同步和异步的任务，需要引进额外的中间任务来衔接，在代码上也不够自然。</p>
<p>如果使用gulp 4.0，只用这样就行了</p><pre class="crayon-plain-tag">function cleanDev() {// TODO}
function cleanDist() {// TODO}
function sprite() {// TODO}
function compileCss() {// TODO}
function compileJs() {// TODO}
function copyHtml() {// TODO}
function reversion() {// TODO}
function replcae() {// TODO}

gulp.task('dist', gulp.series(
    gulp.parallel(
        gulp.series(
            cleanDev,
            gulp.parallel(
                gulp.series(
                    sprite,
                    compileCss
                ),
                compileJs,
                copyHtml
            )
        ),
        cleanDist
    ),
    reversion,
    replcae
));</pre><p><code>gulp.series</code>和<code>gulp.parallel</code>都可以接受以<code>gulp.task</code>注册的任务名干脆就是一个（多个）函数，省去了一大堆gulp.task的代码，同时也达到了任务复用的目的，将子任务经过不同的组合又可以产生新的任务。</p>
<p>结合流程图，上面的代码还是很好理解的。</p>
<p>另外再说一点，只要在gulpfile.js中没有使用gulp.task传三个参数的用法，gulp 4.0也是兼容老版本的gulpfile.js的。</p>
<p><a href="https://github.com/gulpjs/gulp/blob/4.0/CHANGELOG.md">官方升级日志</a>中也列出了一些其他的说明，想升级到4.0又想完全兼容老版本gulpfile.js的开发者最好还是看看咯。</p>
</article>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/07/update-your-gulp/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>这是前端最好的时代——论前端的“三化”建设</title>
		<link>http://www.alloyteam.com/2015/07/zhe-shi-qian-duan-zui-hao-di-shi-dai-lun-qian-duan-di-san-hua-jian-she/</link>
		<comments>http://www.alloyteam.com/2015/07/zhe-shi-qian-duan-zui-hao-di-shi-dai-lun-qian-duan-di-san-hua-jian-she/#comments</comments>
		<pubDate>Tue, 28 Jul 2015 01:50:55 +0000</pubDate>
		<dc:creator><![CDATA[TAT.heyli]]></dc:creator>
				<category><![CDATA[Web开发]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=7950</guid>
		<description><![CDATA[CSDN原文链接：http://www.csdn.net/article/2015-07-17/2825243 [&#8230;]]]></description>
				<content:encoded><![CDATA[<p><strong>CSDN原文链接：</strong><a href="http://www.csdn.net/article/2015-07-17/2825243-alloy-team-leehey" target="_blank">http://www.csdn.net/article/2015-07-17/2825243-alloy-team-leehey</a></p>
<p>&nbsp;</p>
<p><strong>摘要：</strong>深JS大会近日在深圳举办，涵盖了JS领域众多热点话题，很多专家的精彩分享更是引起参会者的诸多思考，如赫门演讲中提出的“每18至24个月，前端都会难一倍”。本文来自腾讯AlloyTeam李成熙，分享了他参会的所见所感。</p>
<p><b>JS中国开发者大会于7月11-12日在深圳成功举办。该大会号称JavaScript和Node.js领域含金量最高的技术分享大会，聚集了来自国内外20多位讲师及大量JS技术爱好者，几乎涵盖了JS领域的所有热点话题。会后，腾讯AlloyTeam李成熙特别撰写了该文章，分享了他参会的<b>所见所感。</b></b></p>
<p><span id="more-7950"></span></p>
<p>“每18至24个月，前端都会难一倍”（注：2015深JS大会上，赫门在《前端服务化之路》主题演讲中说的一句话）。难，是前端发展史偶然中的必然。但难，也造就着前端当下的繁荣。</p>
<p>Ryan Dah之所以选择用Javascript作为Node.js的基础语言，主要是因为它是单线程的，没有服务器I/O，没有历史包袱，有较低的门槛和比较良好的社区（更多内容可见：<a href="http://bostinno.streetwise.co/2011/01/31/node-js-interview-4-questions-with-creator-ryan-dahl/" target="_blank">Node.js Interview: 4 Questions with Creator Ryan Dahl</a>）。这看似是偶然，但实际上正是Javascript的这些优秀特性必然被历史选择，承担推动Web技术发展的使命。</p>
<p>7月11-12日在深JS大会上，我们看见的是在Node.js的推动下，前端技术大放异彩，逐渐告别“石器时代”，走向“工业时代”。而通过推动前端迈进”工业时代”的“三化“建设的力量，分别是前端的自动化、实时化与服务化。</p>
<p><b>前端自动化</b></p>
<p>前端的自动化技术已经发展了好几年，之前涌现的grunt、gulp已帮助前端很好地解决了代码压缩、生成md5、合图等功能。自动化属于“三化”中的基础，它的发展极大释放了前端的手脚，让前端有更多的时间专注于实时化与服务化的发展。大会带来与前端相关的主题是前端的测试自动化。这相信是前端自动化比较棘手的问题。</p>
<p>马逸清给我们展示了七牛存储在前端测试上的一些尝试。但目前来看成果还是相当有限的。其一，他们的做法主要是针对于JavaScript的逻辑，或者是一些基本的UI交互的测试，浏览器兼容性的测试、前端页面与设计稿对齐方面的测试，基本都是空白。其二，即使他们现在可以对JavaScript的逻辑进行测试，但比较好的切入条件是对DOM的隔离，所以，如果业务使用的是View与Model的框架，如Angular，测试是比较友好的。但如果使用到的是Web Component——这种将JavaScript，CSS和HTML模块化地放在一起的元素，则比较麻烦。</p>
<p>对于前端页面与设计稿对齐的测试，我们团队AlloyTeam也有一些尝试，曾开发过一个AlloyDesigner的工具。而对于浏览器兼容性测试，在IE流行的时代，为了兼容IE，很多人喜欢用一个叫IE Tester的工具。但这些都只属于测试的工具化，离自动化还有很长的距离。</p>
<p><img src="http://top.oa.com/apis/imgcache.php/http://img.ptcms.csdn.net/article/201507/17/55a8b1f879b7e.jpg" alt="" /></p>
<p>另外，马逸清还提到，写这些测试代码要增加约20%至30%的工作时间。这对于人手不足、业务时间急、需求迭代快的团队，是一个不少的挑战。而且这个幅度的时间增加，对这些团队来说，可能有违自动化的核心理念——效率的提高。</p>
<p>因此，前端的自动化下一步需要关注的是，拓展测试可覆盖的场景，以及减少额外的时间开销。</p>
<p><b>前端服务化</b></p>
<p>所谓服务化，即使用者只需调用，而毋须知道内部的实现，说白了就是标准化（引自2015深JS大会上，赫门主题演讲《前端服务化之路》的内容）。Node.js的出现使前端服务化成为可能。Node.js开发的系统可以作为接入层，调用Java、C++等提供的基础功能，处理数据库，然后将数据吐给浏览器进行渲染。简易言之，就是用Node.js代替业务逻辑这一层。最后造就的成果是，不仅Java，C++可以放弃业务逻辑，更专注于数据处理的基础服务，而且Node.js能更专注于业务逻辑，挺供API服务给浏览器端的代码进行调用。</p>
<p>用Node.js作为接入层，让前端涉足“后台”的业务成为可能，而且能提高开发效率，还能更方便地使用最新Web技术，如Big Pipe，WebSocket等对页面进行优化。早前淘宝进行的前后端分离，腾讯AlloyTeam正在进行的玄武框架，都是在推动前端服务化做出努力。</p>
<p>除了Node.js作为接入层提供服务以外，淘宝的赫门还提出了将前端Web Component作为一种服务，提供给后台使用。Javascript的AMD与CommonJS规范的订立使Javascript的模块化开发成为可能，也就自然而然地推动了前端的组件化。但赫门认为组件化的Web Component是散乱的，并没有办法一统江湖（如Angular、React这类框架），而他的理念就是希望帮助Web Component重新定位，也就是将其标准化。他在演讲中举出一个应用场景：使用React开发了一个组件，给前端直接使用React，而给后端用的时候则先用Flipper输出成Web Component再用。赫门的这个Flipper在技术上并没有太大的新意，其创新之处在于，他基于Flipper提出的服务化理念。</p>
<p>AlloyTeam内部其实有类似的更完善的方案—— MVVM框架<a href="https://github.com/imweb/Q.js">Q.js</a>及<a href="https://github.com/miniflycn/Ques" target="_blank">Ques</a>组件方案。赫门的Flipper只管将代码转成标准化Web Component，而Ques组件方案不仅在开发过程中可以用标准化Web Component，而且在基于构建，开发的过程中就已经可以将HTML，CSS及JS模块化，更好地组织代码。而Q.js则是一个类Vue.js的的MVVM框架，它可以使用Ques组件方案，结合MVVM框架的特性，能够轻松驾驭一个项目的开发 Ques。</p>
<p><b>前端实时化</b></p>
<p>我不确定用实时化这个词来形容是否恰当，但不可否认的是，Web技术的发展使网页获得更好的响应。目前比较流行的方案就是前端SPA（单页应用）技术结合后台的API服务，他们的桥梁是诞生刚满10年的Ajax。 未来，这种趋势会得到强化，而且Web的体验会越来越贴近应用。</p>
<p>会上，前Googler尤雨溪带来的Meteor正致力于完善这件事。一般的单页应用都如下图，UI、客户端数据和服务器数据相互沟通，达到状态的更新。而Meteor则希望将客户端数据这一层变薄甚至直接去掉，以减少性能的损耗，因此他们在客户端引入一种叫Minimongo的数据库驱动，它遵守DDP（分布式数据协议），根据Meteor的说法，是一种简易的结构化数据获取及数据更新协议。它的特色是，可以在客户端直接定制想要订阅的数据格式，服务器根据请求对订阅者进行推送。Meteor的另一个特色是使用了WebSocket技术。如果你打开TeleScope（使用Meteor技术的一个BBS应用），你能发现它是通过WebSocket获取数据的实时应用。也正因为Meteor使用WebSocket这个HTML5新特性，Meteor将DDP亲切地称为WebSocket的REST。</p>
<p><img src="http://km.oa.com/files/post_photo/574/247574/f967eab90a466dff51ac176aa3e34abb1437123122.jpg" alt="" /></p>
<p>图片来源： 深JS上，尤雨溪的演讲PPT《<a href="http://slides.com/evanyou/shenjs#/" target="_blank">Database Everywhere: a Reactive Data Architecture for JavaScript Frontends</a>》</p>
<p>另一个讲者，Strikingly CTO郭达峰提到Facebook最近打算开源的一种新技术GraphQL，结合Relay和Reactive，是最新比较热门的Web开发方案。这种方案跟Meteor相比其实有异曲同工之妙。在通信结构方案，这种方案遵循上图，React负责UI状态，Relay负责客户端数据状态，而GraphQL则负责服务器数据状态。在通信协议方案，与Meteor不同，它并不限于使用WebSocket，它其实更着眼于解决REST的问题。GraphQL在服务器端发布一个类型系统，Relay通过客户端发送一些比较结构化的查询请求来获取数据，如下图。这套解决方案简化了服务器端，以统一的GraphQL接口提供给Relay这一层，Relay会自动获取数据并统一进行数据变更的处理，使数据获取和处理更加高效。</p>
<p><img src="http://top.oa.com/apis/imgcache.php/http://img.ptcms.csdn.net/article/201507/17/55a8b24ab84c2.jpg" alt="" /></p>
<p>图片来源：深JS上，郭达峰的演讲PPT《<a href="https://speakerdeck.com/dfguo/lightning-talk-at-jsconf-2015" target="_blank">GraphQL and Relay</a>》</p>
<p>在实时化应用方面，业界前10年（今年是Ajax诞生10周年）的发展致力于前端的交互与设计方面的优化，例如Ajax的诞生，Angular、React一类框架使单页应用更为普及。又如AlloyTeam的AlloyKit离线包系统，使HybridApp体验更为完美。而看这次大会，站在10年这个分水岭上发表的演讲，像Facebook这样的巨头和Meteor这样的创新型公司正开始着眼于使前后端的数据通信更快更好。</p>
<p><b>结语</b></p>
<p>前端的自动化、服务化和实时化是前端开发中正在发生的变化，是一系列深刻的变革。这些变革使前端的能力更加丰富、创造的应用更加完美。在深圳举办的这次中国Javascript大会上的讲座，都相当精彩，有意无意地反应出业界的这些变化。希望下一届的大会能更加国际化，为我们带来更多的技术干货。</p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/07/zhe-shi-qian-duan-zui-hao-di-shi-dai-lun-qian-duan-di-san-hua-jian-she/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
		</item>
		<item>
		<title>Canvas画椭圆的方法</title>
		<link>http://www.alloyteam.com/2015/07/canvas-hua-tuo-yuan-di-fang-fa/</link>
		<comments>http://www.alloyteam.com/2015/07/canvas-hua-tuo-yuan-di-fang-fa/#comments</comments>
		<pubDate>Sun, 26 Jul 2015 12:28:49 +0000</pubDate>
		<dc:creator><![CDATA[TAT.vorshen]]></dc:creator>
				<category><![CDATA[HTML5]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=7939</guid>
		<description><![CDATA[虽然标题是画椭圆，但是我们先来说说Canvas中的圆 相信大家对于Canvas画圆都不陌生 [crayon-5 [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>虽然标题是画椭圆，但是我们先来说说Canvas中的圆</p>
<p>相信大家对于Canvas画圆都不陌生<span id="more-7939"></span></p><pre class="crayon-plain-tag">oGC.arc(400, 300, 100, 0, 2*Math.PI, false);</pre><p>如上所示，直接调用API就可以了，但是计算机内部却是使用光栅学，利用bresenham算法画圆的，这个我们放到最后来说，先说说利用圆的参数方程画圆</p><pre class="crayon-plain-tag">circle(oGC, 400, 300, 100);
function circle(context, x, y, a) { // x,y是坐标;a是半径
    var r = 1/a; // ①注意：此处r可以写死，不过不同情况下写死的值不同
    context.beginPath();
    context.moveTo(x + a, y);
    for(var i = 0; i &lt; 2 * Math.PI; i += r) {
        context.lineTo(x + a * Math.cos(i), y + a * Math.sin(i));
    }
    context.closePath();
    context.fill();
}</pre><p>原理是什么，相信三角函数不错的童鞋理解起来很容易的，如果不知道的话，注意注释①，我变化一下r的值，相信就立竿见影了~</p>
<p><img class="alignnone" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/1.png" alt="" width="553" height="301" /><img class="alignnone" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/2.png" alt="" width="498" height="240" /></p>
<p><img class="alignnone" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/3.png" alt="" width="501" height="249" /><img class="alignnone" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/43.png" alt="" width="495" height="261" /></p>
<p>r和2*Math.PI配合就是圆的精细程度，在半径为100的时候，r取1/10就可以了，通用的话可以写死，写成r = 1 / a；这样无论半径取大或者小，圆都会很精细，但是性能会有很大影响</p>
<p>现在来看看文章的主角，针对圆来看椭圆的</p><pre class="crayon-plain-tag">function EllipseOne(context, x, y, a, b) {
    var step = (a &gt; b) ? 1 / a : 1 / b;
    context.beginPath();
    context.moveTo(x + a, y);
    for(var i = 0; i &lt; 2 * Math.PI; i += step) {
        context.lineTo(x + a * Math.cos(i), y + b * Math.sin(i));
    }
    context.closePath();
    context.fill();
}</pre><p>和圆基本一样，不过圆只有一个半径，而椭圆分为长轴和短轴了。</p>
<p>看下效果~</p>
<p><img class="alignnone" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/51.png" alt="" width="481" height="241" /></p>
<p>好了，画椭圆成功，文章结束~</p>
<p>&nbsp;</p>
<p>怎么可能！！</p>
<p>就这样结束也太没品了，刚刚是方法一，下面来看其他的</p>
<p>方法二，均匀压缩法</p>
<p>这是我最喜欢的方法，易理解，相比较方法一，性能也快了很多，先贴代码~</p><pre class="crayon-plain-tag">function EllipseTwo(context, x, y, a, b) {
    context.save();
    var r = (a &gt; b) ? a : b;
    var ratioX = a / r;
    var ratioY = b / r;
    context.scale(ratioX, ratioY);
    context.beginPath();
    context.arc(x / ratioX, y / ratioY, r, 0, 2 * Math.PI, false);
    context.closePath();
    context.restore();
    context.fill();
}</pre><p>原理是利用了scale来对一个标准的圆进行压缩，ratioX是横轴缩放比率，ratioY是纵轴缩放比率，就因为这两个值不同，使得将标准圆缩放成了一个椭圆</p>
<p>记得save()和restore()还原context环境，so easy理解的方法</p>
<p>&nbsp;</p>
<p>下面两种方法很高大上，都是利用三次贝塞尔曲线法</p>
<p>方法三，四，贝塞尔法</p><pre class="crayon-plain-tag">function EllipseThree(context, x, y, a, b) {
    var ox = 0.5 * a,
        oy = 0.6 * b;

    context.save();
    context.translate(x, y);
    context.beginPath();
    context.moveTo(0, b);
    context.bezierCurveTo(ox, b, a, oy, a, 0);
    context.bezierCurveTo(a, -oy, ox, -b, 0, -b);
    context.bezierCurveTo(-ox, -b, -a, -oy, -a, 0);
    context.bezierCurveTo(-a, oy, -ox, b, 0, b);
    context.closePath();
    context.fill();
    context.restore();
}

function EllipseFour(context, x, y, a, b) {
    var k = 0.5522848,
    ox = k * a,
    oy = k * b;

    context.translate(x, y);
    context.beginPath();
    context.moveTo(-a, 0);
    context.bezierCurveTo(-a, oy, -ox, -b, 0, -b);
    context.bezierCurveTo(ox, -b, a, -oy, a, 0);
    context.bezierCurveTo(a, oy, ox, b, 0, b);
    context.bezierCurveTo(-ox, b, -a, oy, -a, 0);
    context.closePath();
    context.fill();
}</pre><p>贝塞尔法的核心在于两个控制点的选取，但是它有致命的问题，当lineWidth较宽的时候，椭圆较扁，长轴较尖锐，会出现不平滑的情况</p>
<p>如果不知道什么事贝塞尔的话就自行百度……这个不解释了……</p>
<p>后面还有最后一种光栅法画椭圆，光栅法画圆很简单，画椭圆挺麻烦的，下面是最简单的一种椭圆画法，等于是lineWidth为1px的情况下</p><pre class="crayon-plain-tag">function EllipseFive(context, x, y, a, b) {
    var data = context.getImageData(0, 0, 800, 600);
    var imageData = data.data;
    var tx = 0;
    var ty = b;
    var d = b*b + a*a*(-b + 0.25);
    var mx = a * a / Math.sqrt(a * a + b * b);

    while(tx &lt;= mx) {
        if(d &lt; 0) {
            d += b * b * (2 * tx + 3);
        } else {
            ty--;
            d += b * b * (2 * tx + 3) + 2 * a * a * (1 - ty);
            
        }

        tx++;
        setPix(x + tx, y + ty);
        setPix(x + tx, y - ty);
        setPix(x - tx, y + ty);
        setPix(x - tx, y - ty);
    }

    d = b * b * (tx + 0.5) * (tx + 0.5) + a * a * (ty - 1) * (ty - 1) - a * a * b * b;
    while (ty &gt; 0) {
        if (d &lt; 0) {
            tx++;
            d += b*b*(2 * tx + 2) + a*a*(-2 * ty + 3);
        }
        else {
            d += a*a*(-2 * ty + 3);
        }
        ty--;
        setPix(x + tx, y + ty);
        setPix(x - tx, y + ty);
        setPix(x + tx, y - ty);
        setPix(x - tx, y - ty);
    }

    context.putImageData(data, 0, 0);

    function setPix(x, y){
        console.log(x, y);
        var index = getStartIndex(x, y);
        for(var i = 0; i&lt; 4; i++) {
            if(i == 3) {
                imageData[index + i] = 255;
            }
            else{
                imageData[index + i] = 128;
            }
        }
    }

    function getStartIndex(x, y) {
        return y * 800 * 4 + x * 4;
    }
}</pre><p>给个结果图~</p>
<p><img class="alignnone" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/61.png" alt="" width="509" height="260" /></p>
<p>光栅法的原理在这里就不说啦，那个说的话篇幅很大，在这里也不推荐用光栅法去画椭圆，针对不同线宽很麻烦</p>
<p>ok这篇文章就到这啦，Thanks~</p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/07/canvas-hua-tuo-yuan-di-fang-fa/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>编程小技巧分享(队列回调)</title>
		<link>http://www.alloyteam.com/2015/07/bian-cheng-xiao-ji-qiao-fen-xiang-dui-lie-hui-diao/</link>
		<comments>http://www.alloyteam.com/2015/07/bian-cheng-xiao-ji-qiao-fen-xiang-dui-lie-hui-diao/#comments</comments>
		<pubDate>Sat, 25 Jul 2015 07:45:15 +0000</pubDate>
		<dc:creator><![CDATA[TAT.finlay]]></dc:creator>
				<category><![CDATA[JavaScript]]></category>
		<category><![CDATA[Web开发]]></category>
		<category><![CDATA[经验心得]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=7931</guid>
		<description><![CDATA[&#160; 场景描述 有时候我们会碰到这样的任务场景，需要在一个界面上展示，许多图表内容，而获取图表数据的C [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>&nbsp;</p>
<h1 id="_1">场景描述</h1>
<blockquote><p>有时候我们会碰到这样的任务场景，需要在一个界面上展示，许多图表内容，而获取图表数据的CGI做得非常原子化，也不方便更改，那么只能发很多个请求来拉取数据，展示图表，大致像下面的界面。<br />
<a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/liushui.png"><img class="alignnone size-full wp-image-7933" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/liushui.png" alt="liushui" width="1528" height="784" /></a><br />
或者有时候，希望一系列函数按照一定顺序自动执行，但里面内嵌各种回调，完全不知道函数何时执行。可能不得不使用标志位来记录执行阶段。(当然可以使用promise,这里是尝试给出另外一种解决方案和思路),这样代码看来一团糟，作为有处女座潜质的程序员多少有些纠结。</p></blockquote>
<p>背景交代完毕，现在是正题，小技巧分享。<br />
其实呢，我们需要的只是一个有加载顺序的队列来完成任务。<br />
但是这里有个思维难点是程序执行流程并非线性推进，而是通过事件推进，不符合常规的线性思维方式。</p>
<p>我就想了一种可以让代码看起来更线性的一种方案.</p>
<p>代码如下:</p><pre class="crayon-plain-tag">var queuePool = (function(){
var pools = [] , 
    isRunning = false ;
    function walk(){
        var runner = pools.shift();
        if( runner ){
            runner( walk );
        }else{
            isRunning = false ;
        }
    }
    return {
        add : function( fn ){
            pools.push( fn );
        } ,
        run : function(){
            if( !isRunning ){
                isRunning = true ;
                walk();
            }
        }
    };
})();
//添加一个执行队列函数
queuePool.add( function( callback /**后续执行函数**/ ){
    setTimeout( function(){
        alert(1);
        callback();
    } , 500 );  
});
queuePool.add( function( callback /**后续执行函数**/ ){
    setTimeout( function(){
        alert(2);
        callback();
    } , 1500 );  
});
queuePool.add( function( callback /**后续执行函数**/ ){
    alert(3);
});
queuePool.run();
queuePool.add( function( callback /**后续执行函数**/ ){
    $.ajax({
        url : url ,
        data : {
            date : formatTime( new Date() ),
            referer : data.referer
        } ,
        dataType : “json” ,
        success : function( response ){
            var data = [] , i = 0 ,
                result = response.result.data;
            for( ; i &lt; result.length ; ++i ){
                data.push( Number( result[i].counter ) );
            }
            $(el).kendoSparkline({
                            data: data 
                        }); 
            callback();             
        } ,
        fail : function(){ 
            callback(); 
        }
    });     
});
queuePool.run();</pre><p>这里我做的事情就是将队列函数，交给调用方自己来决定，何时执行。<br />
同时run是个幂等函数，方便随时调用，还可以保证只有一个队列在执行，且不被多次调用。<br />
这样就满足了开场需求，在ajax中顺序回调:)</p>
<p>&nbsp;</p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/07/bian-cheng-xiao-ji-qiao-fen-xiang-dui-lie-hui-diao/feed/</wfw:commentRss>
		<slash:comments>6</slash:comments>
		</item>
		<item>
		<title>HTML5实现屏幕手势解锁</title>
		<link>http://www.alloyteam.com/2015/07/html5-shi-xian-ping-mu-shou-shi-jie-suo/</link>
		<comments>http://www.alloyteam.com/2015/07/html5-shi-xian-ping-mu-shou-shi-jie-suo/#comments</comments>
		<pubDate>Fri, 17 Jul 2015 12:44:39 +0000</pubDate>
		<dc:creator><![CDATA[TAT.tennylv]]></dc:creator>
				<category><![CDATA[作品]]></category>
		<category><![CDATA[手势解锁]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=7923</guid>
		<description><![CDATA[效果展示 实现原理 利用HTML5的canvas，将解锁的圈圈划出，利用touch事件解锁这些圈圈，直接看代码 [&#8230;]]]></description>
				<content:encoded><![CDATA[<p><strong>效果展示</strong></p>
<p><img class="alignnone" src="http://7jpp2v.com1.z0.glb.clouddn.com/testh5lock.gif" alt="" width="372" height="471" /><br />
<span id="more-7923"></span><br />
<strong>实现原理</strong> 利用HTML5的canvas，将解锁的圈圈划出，利用touch事件解锁这些圈圈，直接看代码。</p><pre class="crayon-plain-tag">function createCircle() {// 创建解锁点的坐标，根据canvas的大小来平均分配半径

        var n = chooseType;// 画出n*n的矩阵 
        lastPoint = [];
        arr = [];
        restPoint = [];
        r = ctx.canvas.width / (2 + 4 * n);// 公式计算 半径和canvas的大小有关
        for (var i = 0 ; i &lt; n ; i++) {
            for (var j = 0 ; j &lt; n ; j++) {
                arr.push({
                    x: j * 4 * r + 3 * r,
                    y: i * 4 * r + 3 * r
                });
                restPoint.push({
                    x: j * 4 * r + 3 * r,
                    y: i * 4 * r + 3 * r
                });
            }
        }
        //return arr;
    }</pre><p>canvas里的圆圈画好之后可以进行事件绑定</p><pre class="crayon-plain-tag">function bindEvent() {
        can.addEventListener("touchstart", function (e) {
             var po = getPosition(e);
             console.log(po);
             for (var i = 0 ; i &lt; arr.length ; i++) {
                if (Math.abs(po.x - arr[i].x) &lt; r &amp;&amp; Math.abs(po.y - arr[i].y) &lt; r) { // 用来判断起始点是否在圈圈内部

                    touchFlag = true;
                    drawPoint(arr[i].x,arr[i].y);
                    lastPoint.push(arr[i]);
                    restPoint.splice(i,1);
                    break;
                }
             }
         }, false);
         can.addEventListener("touchmove", function (e) {
            if (touchFlag) {
                update(getPosition(e));
            }
         }, false);
         can.addEventListener("touchend", function (e) {
             if (touchFlag) {
                 touchFlag = false;
                 storePass(lastPoint);
                 setTimeout(function(){

                    init();
                }, 300);
             }


         }, false);
    }</pre><p>接着到了最关键的步骤绘制解锁路径逻辑，通过touchmove事件的不断触发，调用canvas的moveTo方法和lineTo方法来画出折现，同时判断是否达到我们所画的圈圈里面，其中lastPoint保存正确的圈圈路径，restPoint保存全部圈圈去除正确路径之后剩余的。 Update方法：</p><pre class="crayon-plain-tag">function update(po) {// 核心变换方法在touchmove时候调用
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        for (var i = 0 ; i &lt; arr.length ; i++) { // 每帧先把面板画出来
            drawCle(arr[i].x, arr[i].y);
        }

        drawPoint(lastPoint);// 每帧花轨迹
        drawLine(po , lastPoint);// 每帧画圆心

        for (var i = 0 ; i &lt; restPoint.length ; i++) {
            if (Math.abs(po.x - restPoint[i].x) &lt; r &amp;&amp; Math.abs(po.y - restPoint[i].y) &lt; r) {
                drawPoint(restPoint[i].x, restPoint[i].y);
                lastPoint.push(restPoint[i]);
                restPoint.splice(i, 1);
                break;
            }
        }

    }</pre><p>最后就是收尾工作，把路径里面的lastPoint保存的数组变成密码存在localstorage里面，之后就用来处理解锁验证逻辑了</p><pre class="crayon-plain-tag">function storePass(psw) {// touchend结束之后对密码和状态的处理
        if (pswObj.step == 1) {
            if (checkPass(pswObj.fpassword, psw)) {
                pswObj.step = 2;
                pswObj.spassword = psw;
                document.getElementById('title').innerHTML = '密码保存成功';
                drawStatusPoint('#2CFF26');
                window.localStorage.setItem('passwordx', JSON.stringify(pswObj.spassword));
                window.localStorage.setItem('chooseType', chooseType);
            } else {
                document.getElementById('title').innerHTML = '两次不一致，重新输入';
                drawStatusPoint('red');
                delete pswObj.step;
            }
        } else if (pswObj.step == 2) {
            if (checkPass(pswObj.spassword, psw)) {
                document.getElementById('title').innerHTML = '解锁成功';
                drawStatusPoint('#2CFF26');
            } else {
                drawStatusPoint('red');
                document.getElementById('title').innerHTML = '解锁失败';
            }
        } else {
            pswObj.step = 1;
            pswObj.fpassword = psw;
            document.getElementById('title').innerHTML = '再次输入';
        }

    }</pre><p><strong>解锁组件</strong></p>
<p>将这个HTML5解锁写成了一个组件，放在<a href="https://github.com/lvming6816077/H5lock" target="_blank">https://github.com/lvming6816077/H5lock</a></p>
<p>二维码体验： <img class="alignnone" src="https://camo.githubusercontent.com/7f4c6fe6bd74d440af5f03240c4c67a23dcd0f7a/687474703a2f2f6c766d696e67363831363037372e6769746875622e696f2f483546756c6c73637265656e506167652f48356c6f636b64656d6f2f313433363731333937352e706e67" alt="" width="280" height="280" /></p>
<p>&nbsp;</p>
<p>参考资料：<a href="http://www.nihaoshijie.com.cn/index.php/archives/537" target="_blank">http://www.nihaoshijie.com.cn/index.php/archives/537</a></p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/07/html5-shi-xian-ping-mu-shou-shi-jie-suo/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
		<item>
		<title>AEditor快速上手教程</title>
		<link>http://www.alloyteam.com/2015/07/aeditor-kuai-su-shang-shou-jiao-cheng/</link>
		<comments>http://www.alloyteam.com/2015/07/aeditor-kuai-su-shang-shou-jiao-cheng/#comments</comments>
		<pubDate>Sun, 12 Jul 2015 09:18:43 +0000</pubDate>
		<dc:creator><![CDATA[TAT.Cson]]></dc:creator>
				<category><![CDATA[Web开发]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=7840</guid>
		<description><![CDATA[本教程演示如何使用AEditor制作一个简单的H5交互页demo: &#160; 交互页demo地址： 点击打 [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>本教程演示如何使用AEditor制作一个简单的H5交互页demo:</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/37.jpg"><img class="alignnone  wp-image-7854" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/37.jpg" alt="37" width="423" height="752" /></a></p>
<p>&nbsp;</p>
<p>交互页demo地址：</p>
<p><a href="http://aeditor.alloyteam.com/demo/index.html" target="_blank">点击打开H5交互页demo</a></p>
<p>&nbsp;</p>
<p>AEditor访问地址：</p>
<p><a href="http://aeditor.alloyteam.com" target="_blank">http://aeditor.alloyteam.com</a><br />
<span id="more-7842"></span><br />
<strong>Step1：设置页面背景颜色</strong></p>
<p>首先我们设置页面的背景颜色，右击舞台点击“设置背景”：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/1.jpg"><img class="alignnone  wp-image-7855" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/1.jpg" alt="1" width="507" height="377" /></a></p>
<p>&nbsp;</p>
<p>然后在背景颜色中填上色值rgb(38, 61, 102)，或者选择自己喜欢的颜色：</p>
<p><img class="alignnone" src="http://images.cnblogs.com/cnblogs_com/Cson/711216/o_2.jpg" alt="" width="1" height="1" /><img class="alignnone" src="http://images.cnblogs.com/cnblogs_com/Cson/711216/o_2.jpg" alt="" width="1" height="1" /><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/2.jpg"><img class="alignnone  wp-image-7856" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/2.jpg" alt="2" width="438" height="387" /></a></p>
<p>&nbsp;</p>
<p>点击确定，设置页面背景颜色成功。</p>
<p>&nbsp;</p>
<p><strong>Step2：AEditor标题文字动画制作</strong></p>
<p>首先，点击“文字”按钮，添加文本到AEditor，并改变输入内容为AEditor：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/4.jpg"><img class="alignnone  wp-image-7865" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/4.jpg" alt="4" width="191" height="156" /></a></p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/3.jpg"><img class="alignnone  wp-image-7864" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/3.jpg" alt="3" width="537" height="161" /></a></p>
<p>&nbsp;</p>
<p>设置文字的颜色为浅蓝，并且设置大小为33px，此时文字样式初始化完成：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/42.png"><img class="alignnone  wp-image-7859" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/42.png" alt="4" width="481" height="410" /></a></p>
<p>&nbsp;</p>
<p>要对文字应用渐变向下的动画，我们需要把文字添加到时间轴。右击文字，选择”添加到时间轴“：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/5.png"><img class="alignnone  wp-image-7860" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/5.png" alt="5" width="430" height="485" /></a></p>
<p>点击后会发现顶部多了对应该文字的时间轴：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/5.jpg"><img class="alignnone  wp-image-7861" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/5.jpg" alt="5" width="618" height="142" /></a></p>
<p>&nbsp;</p>
<p>此时我们就可以开始具体到帧的动画编辑了。</p>
<p>帧动画的时长默认是6s，我们并不需要这么长的动画时间。所以我们选中该时间轴，把时长改成1s，发现此时时间轴变短了，只有1s的动画时长：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/6.png"><img class="alignnone  wp-image-7862" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/6.png" alt="6" width="548" height="153" /></a></p>
<p>&nbsp;</p>
<p>选择第一个关键帧，把透明度设置为0，缓动选择easeout：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/7.jpg"><img class="alignnone  wp-image-7866" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/7.jpg" alt="7" width="273" height="90" /></a></p>
<p>再选择最后一个帧，把右则属性编辑器的Y值设置为60（此时会生成新的关键帧）：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/6.jpg"><img class="alignnone  wp-image-7867" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/6.jpg" alt="6" width="292" height="143" /></a></p>
<p>&nbsp;</p>
<p>然后点击播放，则可看到文字渐变向下出现的动画。</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/9.jpg"><img class="alignnone  wp-image-7868" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/9.jpg" alt="9" width="311" height="161" /></a></p>
<p>&nbsp;</p>
<p>另外描述部分的动画制作过程大同小异，就不详述了，描述部分添加到AEditor的效果：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/20.jpg"><img class="alignnone  wp-image-7869" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/20.jpg" alt="20" width="504" height="405" /></a></p>
<p>&nbsp;</p>
<p><strong>Step2：制作企鹅logo动画</strong></p>
<p>图片素材：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/alloy.png"><img class="alignnone  wp-image-7871" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/alloy.png" alt="alloy" width="214" height="214" /></a></p>
<p>&nbsp;</p>
<p>点击“图片”按钮，上传企鹅logo：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/7.png"><img class="alignnone  wp-image-7872" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/7.png" alt="7" width="168" height="120" /></a></p>
<p>图片添加到AEditor：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/8.png"><img class="alignnone  wp-image-7873" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/8.png" alt="8" width="440" height="422" /></a></p>
<p>由于图片要应用动画，一样右击添加到时间轴，时长设置为1.2s。</p>
<p>然后选择第一个关键帧，透明度设置为0，缓动设置为easeout：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/10.jpg"><img class="alignnone  wp-image-7874" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/10.jpg" alt="10" width="274" height="88" /></a></p>
<p>由于我们想让动画延迟0.2s开始，所以把第一个关键帧右击“复制”：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/11.jpg"><img class="alignnone  wp-image-7877" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/11.jpg" alt="11" width="345" height="193" /></a></p>
<p>然后右击0.2s处的帧，选择“粘贴”，此时就把第一个关键帧复制到0.2s处了：</p>
<p><img class="alignnone  wp-image-7875" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/12.jpg" alt="12" width="386" height="187" /></p>
<p>&nbsp;</p>
<p>粘贴完成：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/9.png"><img class="alignnone  wp-image-7878" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/9.png" alt="9" width="433" height="207" /></a></p>
<p>&nbsp;</p>
<p>此时再选择最后一个帧，设置选装rotateZ为720度，透明度为1：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/14.jpg"><img class="alignnone  wp-image-7879" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/14.jpg" alt="14" width="143" height="106" /></a> <a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/13.jpg"><img class="alignnone  wp-image-7880" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/13.jpg" alt="13" width="134" height="81" /></a></p>
<p>&nbsp;</p>
<p>再次点击播放动画，则可看到翻转动画播放。</p>
<p>&nbsp;</p>
<p><strong>Step3：制作企鹅logo点击翻转动画</strong></p>
<p>接下来我们制作点击企鹅logo，logo播放翻转动画。</p>
<p>首先设置企鹅logo的点击行为，右击企鹅Logo，选择“设置点击行为”：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/11.png"><img class="alignnone  wp-image-7881" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/11.png" alt="11" width="230" height="311" /></a></p>
<p>勾上触发自定义事件，然后填入要触发的事件名“rotate”：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/16.jpg"><img class="alignnone  wp-image-7882" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/16.jpg" alt="16" width="336" height="247" /></a></p>
<p>&nbsp;</p>
<p>点击确定，此时可以看到企鹅Logo上有点击事件标识，点击企鹅会触发rotate事件：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/13.png"><img class="alignnone  wp-image-7884" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/13.png" alt="13" width="474" height="433" /></a></p>
<p>此时我们需要建立事件监听播放翻转动画，右击企鹅Logo，选择添加事件动画：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/15.jpg"><img class="alignnone  wp-image-7886" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/15.jpg" alt="15" width="288" height="327" /></a></p>
<p>&nbsp;</p>
<p>填入需要监听的事件名，所以我们填入“rotate”：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/12.png"><img class="alignnone  wp-image-7887" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/12.png" alt="12" width="516" height="276" /></a></p>
<p>&nbsp;</p>
<p>点击确定，此时会看到生成的对应事件的动画时间轴，并看到“rotate”的事件标识：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/17.jpg"><img class="alignnone  wp-image-7888" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/17.jpg" alt="17" width="331" height="125" /></a></p>
<p>&nbsp;</p>
<p>然后选择第一个关键帧，透明度设置为1，最后创建一个关键帧旋转rotateY设置为720，中间创建一个关键帧，透明度设置为0：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/17.png"><img class="alignnone  wp-image-7889" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/17.png" alt="17" width="336" height="134" /></a></p>
<p>&nbsp;</p>
<p>此时点击“播放全部”按钮，并且点击企鹅Logo，会播放对应翻转动画：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/19.jpg"><img class="alignnone  wp-image-7890" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/19.jpg" alt="19" width="212" height="61" /></a></p>
<p>&nbsp;</p>
<p><strong>Step4：添加新的一页</strong></p>
<p>此时第一页交互动画已制作完毕，点击页控制的“+”按钮，添加新的一页，并设置背景颜色同上一页：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/21.jpg"><img class="alignnone  wp-image-7891" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/21.jpg" alt="21" width="219" height="327" /></a></p>
<p>另外改变一下翻页动画的类型，设置为“渐变移动”：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/22.jpg"><img class="alignnone  wp-image-7892" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/22.jpg" alt="22" width="217" height="211" /></a></p>
<p>&nbsp;</p>
<p>点击“播放全部”按钮，可以通过鼠标上下滑动看到翻页效果：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/23.jpg"><img class="alignnone  wp-image-7893" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/23.jpg" alt="23" width="495" height="758" /></a></p>
<p>&nbsp;</p>
<p><strong>Step5：创建多行文本，添加预设动画</strong></p>
<p>对于单行文本，我们使用“文本”按钮添加对应文字，但对于多行文本，我们可以添加图层，然后在图层上编辑添加文字。</p>
<p>点击“图层”按钮添加图层：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/24.jpg"><img class="alignnone  wp-image-7894" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/24.jpg" alt="24" width="187" height="154" /></a></p>
<p>通过手柄把图层尺寸拉到一定大小并居中：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/14.png"><img class="alignnone  wp-image-7895" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/14.png" alt="14" width="541" height="372" /></a></p>
<p>双击图层，进入文字编辑状态，此时可往图层中填充文字：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/15.png"><img class="alignnone  wp-image-7896" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/15.png" alt="15" width="690" height="403" /></a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>同样我们要为文字添加动画效果，所以编辑文字完成之后，右击文字区域，添加到时间轴。</p>
<p>此时我们准备从预设动画中选择一个从下向上的动画，应用到文字区域中，选择第一个关键帧，点击插入预设动画：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/25.jpg"><img class="alignnone  wp-image-7897" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/25.jpg" alt="25" width="196" height="103" /></a></p>
<p>&nbsp;</p>
<p>此时会看到弹出的预设动画选择框，从中选择动画“从下弹入”：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/26.jpg"><img class="alignnone  wp-image-7898" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/26.jpg" alt="26" width="661" height="615" /></a></p>
<p>&nbsp;</p>
<p>右则预览窗口可以预览预设动画的效果，点击确定，此时会自动创建对应预设动画的所有关键帧：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/27.jpg"><img class="alignnone  wp-image-7899" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/27.jpg" alt="27" width="396" height="204" /></a></p>
<p>&nbsp;</p>
<p>点击播放按钮，可以看到文字从下往上弹入的动画效果。</p>
<p>&nbsp;</p>
<p>此时我们选择1.5s处的帧，再次添加预设动画“橡皮筋”，点击确定，再次自动生成对应的所有关键帧：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/28.jpg"><img class="alignnone  wp-image-7900" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/28.jpg" alt="28" width="591" height="119" /></a></p>
<p>&nbsp;</p>
<p>点击播放按钮预留动画，在从下弹入后会再播放橡皮筋效果动画，如果希望对预设动画进行微调，可以手动对关键帧进行二次编辑。</p>
<p>&nbsp;</p>
<p><strong>Step6：建立元件，创建文字的组合动画</strong></p>
<p>最后是“By AlloyTeam”这行文字的动画，这个动画有点特殊，文字边闪烁边往右移动。</p>
<p>如果用上面的方式编辑动画的话，可想而知就很麻烦了，闪烁的位置以及对应移动的位置都要手动设置对应关键帧，难以控制的同时也带来了多个难以维护的关键帧。</p>
<p>因此我们使用元件的方式创建该动画。</p>
<p>我们首先把闪烁的文字作为一个元件创建，再为元件整体创建从左到右移动的动画。</p>
<p>&nbsp;</p>
<p>点击“新建元件”按钮，进入元件模式创建元件：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/29.jpg"><img class="alignnone  wp-image-7902" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/29.jpg" alt="29" width="188" height="190" /></a></p>
<p>元件名称设置为“text”，元件尺寸设置为150*40：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/16.png"><img class="alignnone  wp-image-7903" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/16.png" alt="16" width="539" height="234" /></a></p>
<p>&nbsp;</p>
<p>进入元件模式之后添加文字并设置为“By Alloyteam”，文字颜色设置为淡黄，同时添加到时间轴。</p>
<p>然后动画时长设置为1s，选择中间关键帧设置透明度为0，最后一个关键帧透明度为1：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/171.png"><img class="alignnone  wp-image-7904" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/171.png" alt="17" width="331" height="132" /></a></p>
<p>点击播放，此时可以看到文字的一次闪烁动画。</p>
<p>&nbsp;</p>
<p>然而，我们希望文字在动画期间连续闪烁3次，此时我们可以选择该时间轴，勾上“重复播放”选项，并且设置“播放次数”为3：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/18.png"><img class="alignnone  wp-image-7905" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/18.png" alt="18" width="642" height="185" /></a></p>
<p>点击播放按钮，此时可以看到动画播放了3次。</p>
<p>&nbsp;</p>
<p>点击“保存元件”把元件保存下来，再点击&#8221;回到场景&#8221;：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/30.jpg"><img class="alignnone  wp-image-7906" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/30.jpg" alt="30" width="189" height="123" /></a></p>
<p>&nbsp;</p>
<p>此时我们需要使用刚才创建的元件，点击”插入元件“:</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/31.jpg"><img class="alignnone  wp-image-7907" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/31.jpg" alt="31" width="183" height="188" /></a></p>
<p>&nbsp;</p>
<p>然后在元件选择栏中选择刚刚创建的元件，右则预览窗口可以预览元件动画效果：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/19.png"><img class="alignnone  wp-image-7909" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/19.png" alt="19" width="593" height="463" /></a></p>
<p>点击确定，此时元件已经被添加到舞台上了：</p>
<p><img class="alignnone  wp-image-7908" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/32.jpg" alt="32" width="510" height="549" /></p>
<p>&nbsp;</p>
<p>此时再为元件整体创建从左到右的动画，首先把元件添加到时间轴，动画时长设置为2s，然后对第一个帧的X值设置为-180，缓动设置为ease，最后一个关键帧设置X值为85：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/33.jpg"><img class="alignnone  wp-image-7910" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/33.jpg" alt="33" width="450" height="130" /></a></p>
<p>&nbsp;</p>
<p>点击播放按钮，可以看到文字边闪烁边从左滑动到右边的动画过程。</p>
<p>&nbsp;</p>
<p><strong>Step7：设置每页动画可重复播放</strong></p>
<p>当前状态下，播放了一页动画之后，再回到该页，动画并不会再次播放，如果我们希望可以多次播放页的动画，可以开启页动画的重复播放设置：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/22.png"><img class="alignnone  wp-image-7911" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/22.png" alt="22" width="208" height="505" /></a></p>
<p>&nbsp;</p>
<p>这样每次跳到一页的时候，该页的动画都会再次播放。</p>
<p>&nbsp;</p>
<p><strong>Step8：导出交互页</strong></p>
<p>此时整个demo页面的动画完成了，可以点击播放全部预览整体效果。</p>
<p>&nbsp;</p>
<p>效果满意之后，点击“导出”按钮，导出该页面的项目结构（zip压缩包）：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/34.jpg"><img class="alignnone  wp-image-7912" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/34.jpg" alt="34" width="179" height="140" /></a></p>
<p>生成的压缩包包含了整个交互页的项目结构：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/35.jpg"><img class="alignnone  wp-image-7913" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/35.jpg" alt="35" width="877" height="415" /></a></p>
<p>&nbsp;</p>
<p>解压到目录，mobile模式下打开index.html即可看到创建的交互页效果：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/07/36.jpg"><img class="alignnone  wp-image-7914" src="http://cdn.alloyteam.com/wp-content/uploads/2015/07/36.jpg" alt="36" width="467" height="735" /></a></p>
<p>&nbsp;</p>
<p>更多关于AEditor的详细教程：</p>
<p><a href="http://www.alloyteam.com/2015/06/h5-jiao-hu-ye-bian-ji-qi-aeditor-jie-shao/" target="_blank">http://www.alloyteam.com/2015/06/h5-jiao-hu-ye-bian-ji-qi-aeditor-jie-shao/</a></p>
<p>&nbsp;</p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/07/aeditor-kuai-su-shang-shou-jiao-cheng/feed/</wfw:commentRss>
		<slash:comments>8</slash:comments>
		</item>
		<item>
		<title>Nuclear开始</title>
		<link>http://www.alloyteam.com/2015/07/nuclear-kai-shi/</link>
		<comments>http://www.alloyteam.com/2015/07/nuclear-kai-shi/#comments</comments>
		<pubDate>Sun, 12 Jul 2015 01:34:31 +0000</pubDate>
		<dc:creator><![CDATA[TAT.dnt]]></dc:creator>
				<category><![CDATA[Web开发]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=7844</guid>
		<description><![CDATA[为什么Nuclear 这里列举Nuclear在竞品中的优势： 借助浏览器本身的机制，无任何代码约定和入侵 放心 [&#8230;]]]></description>
				<content:encoded><![CDATA[<h2>为什么Nuclear</h2>
<p>这里列举Nuclear在竞品中的优势：</p>
<ul>
<li>借助浏览器本身的机制，无任何代码约定和入侵</li>
<li>放心使用HTML+CSS+JS</li>
<li>observejs替代EventLoop、requestAnimationFrame、Ticker等定时循环</li>
<li>解决MV*无法构建复杂特效的难题，随意构建超复杂交互特效，自由地大展拳脚</li>
<li>支持Dom和Canvas组件，未来支持SVG和WebGL.</li>
<li>SVG库Sword已经整装待发：<a href="https://github.com/AlloyTeam/Sword">https://github.com/AlloyTeam/Sword</a></li>
<li>WebGL库pixeljs正在全力推进<a href="https://github.com/kmdjs/pixeljs">https://github.com/kmdjs/pixeljs</a></li>
</ul>
<p><span id="more-7844"></span></p>
<h2>获取Nuclear</h2>
<p>Nuclear网站 <a href="http://alloyteam.github.io/Nuclear/">http://alloyteam.github.io/Nuclear/</a>.</p>
<p>Github <a href="https://github.com/AlloyTeam/Nuclear">https://github.com/AlloyTeam/Nuclear</a></p>
<p>你也可以通过npm安装Nuclear</p><pre class="crayon-plain-tag">npm install alloynuclear</pre><p></p>
<h2>使用Nuclear</h2>
<p>js文件可以在这里找到最新版的: <a href="https://raw.githubusercontent.com/AlloyTeam/Nuclear/master/dist/nuclear.js">nuclear.js</a> or <a href="https://raw.githubusercontent.com/AlloyTeam/Nuclear/master/dist/nuclear.min.js">nuclear.min.js</a></p>
<p>你可以直接在页面引用</p><pre class="crayon-plain-tag">&lt;script src="nuclear.js"&gt;&lt;/script&gt;</pre><p>也可在AMD环境同步 require</p><pre class="crayon-plain-tag">define(function (require) {
    var Nuclear = require('nuclear');
});</pre><p>或者异步 require：</p><pre class="crayon-plain-tag">require([ 'nuclear' ], function (Nuclear) {
});</pre><p>在CommonJS 环境：</p><pre class="crayon-plain-tag">var Nuclear = require('nuclear');</pre><p></p>
<h2>Nuclear直接暴露</h2>
<p>下面是暴露给AMD/CommonJS和Root的代码。</p><pre class="crayon-plain-tag">;(function (root, factory) {
    if (typeof define === 'function' &amp;&amp; define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof define === "function" &amp;&amp; define.cmd) {
        define(function(require, exports, module){
            module.exports=factory();
        });
    }
    root.$ = root.Nuclear  = factory();   
}(this, function () {</pre><p>所以，只要你加载了nuclear.js文件，你就能直接子啊root/window下直接访问到Nuclear。<br />
那么为什么要暴露在root/window?<br />
因为，为了支持声明式事件绑定，即让事件调用自身组件定义的方法。如下面render方法中的模板：</p><pre class="crayon-plain-tag">&lt;form onsubmit="add(event)" &gt;</pre><p>到了dom里面，进过Nuclear的处理会变成：</p><pre class="crayon-plain-tag">&lt;form onsubmit="Nuclear.instances[0].add(event)"&gt;</pre><p>所以add不会去访问全局的add，而是访问自身组件定义的add方法。关于这点后面教程再详细说明这么设计的好处。先看简单的例子。</p>
<h2>简单例子</h2>
<p></p><pre class="crayon-plain-tag">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Hello,Nuclear!&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="container"&gt;&lt;/div&gt;
    &lt;script src="../dist/nuclear.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript"&gt;
        var HelloMessage = Nuclear.create({
            render: function () {
                return '&lt;div&gt;Hello , {{name}} !&lt;/div&gt;';
            }
        })
        new HelloMessage({ name: "Nuclear" }, "#container");
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre><p>new HelloMessage的第一个参数会赋给this.option，render的模板使用的数据源就是this.option。所以，直接通过 {{name}}就能得到option的name的值。<br />
new HelloMessage的第二个参数是组件的容器。</p>
<h2>Q&amp;A</h2>
<p>任何问题可以留言回复或者<a href="https://github.com/AlloyTeam/Nuclear/issues/new">issues</a> 发过来</p>
<p><script src="http://htmljs.b0.upaiyun.com//js/tuiku.js"></script></p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/07/nuclear-kai-shi/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
		</item>
		<item>
		<title>[翻译]Andoird 中事件驱动编程-Event-driven programming for Android (1)</title>
		<link>http://www.alloyteam.com/2015/07/fan-yi-andoird-zhong-shi-jian-qu-dong-bian-cheng-event-driven-programming-for-android/</link>
		<comments>http://www.alloyteam.com/2015/07/fan-yi-andoird-zhong-shi-jian-qu-dong-bian-cheng-event-driven-programming-for-android/#comments</comments>
		<pubDate>Tue, 07 Jul 2015 11:58:13 +0000</pubDate>
		<dc:creator><![CDATA[TAT.iptton]]></dc:creator>
				<category><![CDATA[Android 开发]]></category>
		<category><![CDATA[Event-Driven]]></category>
		<category><![CDATA[EventBus]]></category>
		<category><![CDATA[事件驱动]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=7825</guid>
		<description><![CDATA[Event-driven programming for Android Andoird 中事件驱动编程 ht [&#8230;]]]></description>
				<content:encoded><![CDATA[<p class="p1"><span class="s1" style="color: #999999;"><b>Event-driven programming for Android</b></span></p>
<p class="p1"><span class="s1"><b>Andoird 中事件驱动编程</b></span></p>
<p><a href="https://medium.com/google-developer-experts/event-driven-programming-for-android-part-i-f5ea4a3c4eab">https://medium.com/google-developer-experts/event-driven-programming-for-android-part-i-f5ea4a3c4eab</a></p>
<p class="p2"><span class="s1"><span style="color: #999999;">(This is the first article in a three-part series)</span> (本文是系列文章中的一部分)</span></p>
<p class="p2"><span class="s1" style="color: #808080;">Although Android includes some event-driven features in its development, it is far away from being a pure event-driven architecture. Is this something good or bad? As in every issue with software development the answer is not easy: it depends.</span></p>
<p class="p2"><span class="s1"> 虽然 Android 已经包含了若干事件驱动特性，但其离纯正的事件驱动架构还有一定的距离。这到底是好事还是坏事呢？和多数软件开发问题的答案一样：看情况。</span></p>
<p class="p2"><span id="more-7825"></span></p>
<p class="p2"><span class="s1" style="color: #999999;">First, let’s establish a definition for event-driven development. This is a programming paradigm where the flow of execution is determined by events triggered by actions (such user interaction, messaging from other threads, etc). In this sense, Android is partially event-driven: we all can think of the onClick listeners or the Activity lifecycle, which are events able to trigger actions in an application. Why I said it is not a pure event-driven system? By default, each event is bound to a particular controller, and it is difficult to operate besides it (for example, the onClick events are defined for a view, having a limited scope).</span></p>
<p class="p2"><span class="s1">我们先来为“事件驱动开发”做个定义：事件驱动开发指的事一种编程模式，在此模式下所有的程序流程都决定于事件(event)，而事件又是由行为(action)来触发（如用户交互，来自其他线程的消息等等）。从这方面来看，Android 是部分驱动开发的：我们都能想到 onClick 监听函数或 Activity 的生命周期函数，这些都是由应用里的行为来驱动的事件，那么为什么我们还是说 Android 不是纯粹的事件驱动系统呢？因为，默认情况下，所有的事件都是绑定在各自的控件器里，你很难从外部去操作触发它（例如：onClick 事件是在 view 中定义的，有指定的上下文范围）。</span></p>
<p class="p2"><span class="s1" style="color: #999999;">Wait, you are talking about a new programming paradigm. Adopting frameworks or methodologies has always a cost, could this bring any advantage? I say yes, and to show it I want to present some limitations with traditional Android development.</span></p>
<p class="p2"><span class="s1">等等等等，你是在说一个新的编程模式？移植框架是有代价的，这个新模式能带来什么好处吗？ 我的答案是：可以，为了证明其好处，我要先说下现有的编程模式的几个局限性。</span></p>
<p class="p2"><span class="s1" style="color: #999999;">In many scenarios it will be easy to end up with a structure as the following diagram is showing:</span></p>
<p class="p2"><span class="s1">在多数情况下，我们很容易设计出这样一个代码框架：</span></p>
<p class="p2"><img class="alignnone" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*E8LdhGivILj-DZntgtctrg.png" alt="" width="670" height="454" /></p>
<p class="p2"><span class="s1" style="color: #999999;">Activities can communicate with Fragments, Fragments can send messages to another Fragments and Services. There is a tight coupling of components, and applying changes can be expensive(*). This leads frequently to boilerplate code, interfaces that implement functions that need to callback and propagate through different layers… you probably know where I want to go. As the amount of code increases, the maintainability and good software engineering practices are decreasing.</span></p>
<p class="p2"><span class="s1">Activiy 可以与 Fragment 通信，Fragment 可以发消息给其它 Fragment 或 Services。这是一种紧耦合的组件关系，在其中做修改是比较昂贵的(作者后文标注：I deliberately like to use the word “expensive” when referring to “lot of time”. Thinking in economical terms is frequently more effective.)。这种设计会导致大量的同一格式的代码，所实现的接口需要在不同的层次里进行回调和传递(you probably know where I want to go)&#8230;随着代码的增加，整个工程的可维护性及良好的工程实践都会降低。</span></p>
<p class="p2"><span class="s1" style="color: #999999;">How does event-driven programming apply here? Let’s represent another system proposal:</span></p>
<p class="p2"><span class="s1">那么，在事件驱动编程模式下会怎么处理这种情况呢？请看以下的系统结构图：</span></p>
<p class="p2"><img class="alignnone" src="https://d262ilb51hltx0.cloudfront.net/max/1576/1*8WqRoVCAdoc8c5Tfu5myWQ.png" alt="" width="788" height="405" /><img class="alignnone" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*uw1QaSKhDc_J_zDTMH24ow.png" alt="" width="653" height="294" /></p>
<p class="p2"><img class="alignnone" src="https://d262ilb51hltx0.cloudfront.net/max/1544/1*4FFuBtsHh1OFtm-lts4OSA.png" alt="" width="772" height="411" /></p>
<p class="p2"><span class="s1" style="color: #999999;">Conceptually, the represented system have an event bus. There are different entities subscribed to the Event Bus, and posting events or listening to events — being respectively a producer or a consumer. Any subscriber can perform an action without knowing the logic. Think about it. Think about particular possibilities: a Fragment could render again and update its screen without knowing the logic behind any operation, just knowing that an event took place. Think about the possibilities of decoupling code and having a clean, compartmentalized architecture.</span></p>
<p class="p2"><span class="s1">上图中增加了一个概念：事件总线(event bus)。不同的实例会订阅(发送或监听)事件总线，这里称之为生产者(producer)和消费者(consumer)。如此，可以想到，Fragment 可以在不知道背后任何逻辑和操作的情况下进行渲染，更新屏幕展示，代码充分解耦，而架构也是非常清晰，系统模块划分非常明确。</span></p>
<p class="p2"><span class="s1" style="color: #999999;">Is this paradigm supported in Android? Well, partially. As mentioned, the SDK offers natively a reduced set of event handling techniques, but we we want to go further. There are some names I want to mention here:</span></p>
<p class="p2"><span class="s1">上图展示的结构 Android 支持吗？嗯&#8230;部分支持。上文已提到，Android SDK 提供了一些事件处理功能，但我们希望有更完整的实现。这里想提一提以下开源库：</span></p>
<p class="p2"><span class="s1" style="color: #999999;">EventBus, from greenrobot. This library has been optimized for Android, and has some advanced features like delivery threads and subscriber priorities. Otto, from Square. Originally a fork from Guava, it has evolved and being refined to the Android platform. Having tried both I prefer EventBus over Otto. Greenrobot claims that EventBus is significantly better at performing than its pair, and provides an extra amount of features.</span></p>
<p class="p2"><span class="s1">EventBus，来自 greenrobot。这个库已为 Android 做优化，具有一些高级功能，如：分必线程，订阅者优先级等。 Otto，来自 Square。源于 Guava ，为 Android 平台做了重新的封装改进。</span></p>
<p class="p2"><span class="s1">尝试过两个后，我个人比较喜欢 EventBus。Greenrobot 宣称 EventBus 明显高效于其它竞争对手，并且额外提供了相当多的特性。</span></p>
<p><span style="color: #999999;">The next article will explore how to implement basic functions in EventBus</span></p>
<p class="p2"><span class="s1">下一篇会展示如何使用EventBus。</span></p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/07/fan-yi-andoird-zhong-shi-jian-qu-dong-bian-cheng-event-driven-programming-for-android/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Chrome调试小技巧</title>
		<link>http://www.alloyteam.com/2015/06/chrome-diao-shi-ji-qiao/</link>
		<comments>http://www.alloyteam.com/2015/06/chrome-diao-shi-ji-qiao/#comments</comments>
		<pubDate>Tue, 30 Jun 2015 15:59:40 +0000</pubDate>
		<dc:creator><![CDATA[TAT.joey]]></dc:creator>
				<category><![CDATA[Web开发]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=7787</guid>
		<description><![CDATA[前言： 除了我们日常使用的调试方法，在Chrome中，其含有一些有意思的方法，有助于提高我们的开发调试效率。  [&#8230;]]]></description>
				<content:encoded><![CDATA[<h2><span style="color: #008000;"><strong>前言：</strong></span></h2>
<p>除了我们日常使用的调试方法，在Chrome中，其含有一些有意思的方法，有助于提高我们的开发调试效率。</p>
<p><span id="more-7787"></span></p>
<h2><strong><span style="color: #008000;">Sources页 </span></strong></h2>
<h3><span style="color: #008000;"><strong>command + p  文件跳转</strong></span></h3>
<p>使用Sublime的人或习惯用command + p 进行文件的跳转，在chrome dev tools中其实也有类似的跳转方法。</p><pre class="crayon-plain-tag">command + p  

command + p + 文件名 + : + 数字</pre><p><img class="alignnone size-full wp-image-7797" src="http://cdn.alloyteam.com/wp-content/uploads/2015/06/j5.png" alt="j5" width="525" height="206" /></p>
<h3><span style="color: #008000;"><strong> command + shift + o  任意方法跳转</strong></span></h3>
<p>Sublime中使用command +R 进行方法跳转，而在dev tools中，可以使用command + shift + o  进行任意方法的跳转。</p><pre class="crayon-plain-tag">command + shift + o  // 跳转到任意方法</pre><p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/06/j8.png"><img class="alignnone size-full wp-image-7805" src="http://cdn.alloyteam.com/wp-content/uploads/2015/06/j8.png" alt="j8" width="526" height="201" /></a></p>
<p><em>注： 查找某文件中的方法，使用command + p 和  command + shift + o 更配哦~</em></p>
<h2><strong><span style="color: #008000;">Elements页 </span></strong></h2>
<ul>
<li>使用方向键快，上下键导航，左右键收起展开；</li>
<li>H键快速隐藏dom（效果相当于给DOM加入<span class="webkit-css-property styles-panel-hovered" title="visibility: collapse;">visibility</span>: <span class="value">hidden属性，</span>有别于display:none）</li>
<li>Enter进行快速编辑属性；</li>
<li>鼠标右击使用各类方法&#8230;</li>
</ul>
<h2><strong><span style="color: #008000;">Console页 </span></strong></h2>
<h3><span style="color: #008000;"><strong>$_   表示上次的计算结果</strong></span></h3>
<p>举个栗子</p><pre class="crayon-plain-tag">15 * 15  

$_ * 10</pre><p><img class="alignnone size-full wp-image-7792" style="line-height: 1.5;" src="http://cdn.alloyteam.com/wp-content/uploads/2015/06/屏幕快照-2015-06-30-下午10.43.04.png" alt="屏幕快照 2015-06-30 下午10.43.04" width="560" height="157" /></p>
<h3><span style="color: #008000;"><strong>$0   获取当前选中的DOM</strong></span></h3>
<p>选中DOM之后，在控制台输入$0。</p><pre class="crayon-plain-tag">$0</pre><p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/06/屏幕快照-2015-07-01-上午12.03.53.png"><img class="alignnone  wp-image-7793" src="http://cdn.alloyteam.com/wp-content/uploads/2015/06/屏幕快照-2015-07-01-上午12.03.53.png" alt="屏幕快照 2015-07-01 上午12.03.53" width="556" height="227" /></a></p>
<p><em>注：$1 $2 $3 是获取前几次选的dom，不常用</em></p>
<p>&nbsp;</p>
<h3><span style="color: #008000;"><strong>$(selector) 与 $$(selector)  获取当前选中的DOM</strong></span></h3>
<p>当页面没有引入jQuery等类库的时候，这是我们一般会用<br />
document.querySelector() 或是 document.querySelectorAll() 来作用dom选择器。<br />
而在Chrome调试中我们可以使用是$(selector) 与 $$(selector)来作为选择器，省去大串代码，如下。</p><pre class="crayon-plain-tag">$('body')

$$('body')</pre><p></p>
<h3><img class="alignnone size-full wp-image-7802" src="http://cdn.alloyteam.com/wp-content/uploads/2015/06/j7.png" alt="j7" width="392" height="72" /></h3>
<p>由上图实际结果看出，$()和$$()获取得到的都是满足选中条件元素的一个集合，相当于document.querySelectorAll()</p>
<p><em>注: 实验所用chrome版本：40.0.2214.111 (64-bit)</em></p>
<p>&nbsp;</p>
<p><strong style="color: #008000; line-height: 1.5;">copy(Object)   拷贝对象</strong></p><pre class="crayon-plain-tag">copy(document.body)

copy($0)</pre><p><img class="alignnone size-full wp-image-7794" src="http://cdn.alloyteam.com/wp-content/uploads/2015/06/屏幕快照-2015-06-30-下午10.58.01.png" alt="屏幕快照 2015-06-30 下午10.58.01" width="610" height="200" /></p>
<p><em>注: 可搭配$0来拷贝当前选择的dom，记得手动黏贴~</em></p>
<p>&nbsp;</p>
<p><strong style="color: #008000; line-height: 1.5;">console.time &amp; console.timeEnd  计算耗时</strong></p>
<p>对代码执行的耗时情况进行测试时，处理手工在代码中创建前后两个时间戳进行对比，在dev tools中，我们可以使用console.time与 console.timeEnd实现。</p><pre class="crayon-plain-tag">console.time("测试用时");
var array= new Array(1000000);
for (var i = array.length - 1; i &gt;= 0; i--) {
array[i] = new Object();
};
console.timeEnd("测试用时");</pre><p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/06/j9.png"><img class="alignnone size-full wp-image-7806" src="http://cdn.alloyteam.com/wp-content/uploads/2015/06/j9.png" alt="j9" width="522" height="194" /></a></p>
<p><strong style="color: #008000; line-height: 1.5;">关闭Console界面   </strong></p>
<p>ESC&#8230;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/06/chrome-diao-shi-ji-qiao/feed/</wfw:commentRss>
		<slash:comments>7</slash:comments>
		</item>
		<item>
		<title>快速搭建静态服务器的几种方法</title>
		<link>http://www.alloyteam.com/2015/06/kuai-su-da-jian-jing-tai-fu-wu-qi-di-ji-zhong-fang-fa/</link>
		<comments>http://www.alloyteam.com/2015/06/kuai-su-da-jian-jing-tai-fu-wu-qi-di-ji-zhong-fang-fa/#comments</comments>
		<pubDate>Tue, 30 Jun 2015 15:34:52 +0000</pubDate>
		<dc:creator><![CDATA[TAT.Fujun]]></dc:creator>
				<category><![CDATA[Web开发]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=7763</guid>
		<description><![CDATA[作为一名前端开发人员，经常也是需要有一个静态服务器的。下面让我们来分分钟搭建自己的静态服务器吧 一：使用htt [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>作为一名前端开发人员，经常也是需要有一个静态服务器的。下面让我们来分分钟搭建自己的静态服务器吧</p>
<p><strong>一：使用http-server</strong></p>
<p>http-server基于Node，所以得先确保有Node环境。</p>
<p><span id="more-7763"></span></p>
<p>1. 安装http-server</p><pre class="crayon-plain-tag">npm install http-server -g</pre><p>2. 启动</p><pre class="crayon-plain-tag">http-server -a 127.0.0.1 -p 9999</pre><p>上面的命令表示在本机的9999端口上启动一个静态服务器，应用根目录为执行上面命令的所在目录<a href="http://cdn.alloyteam.com/wp-content/uploads/2015/06/211.png"><img class="alignnone  wp-image-7765" src="http://cdn.alloyteam.com/wp-content/uploads/2015/06/211.png" alt="2" width="771" height="90" /></a></p>
<p><span style="text-decoration: underline;">优点：简单，快速</span><br />
<span style="text-decoration: underline;">缺点：命令行一关，服务就中止了。每次开机都要再启一次，麻烦</span></p>
<p><strong>二：使用ApmServer/XAMPP</strong><br />
两者都是PHP的集成环境，这里以ApmServer为例（只有用过ApmServer）。</p>
<p>首先在网上下载ApmServer的压缩包（免安装），解压到一个盘的根目录（建议是根目录，因为路径有空格可能造成一些不必要的麻烦），下面是其解压后的目录结构：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/06/31.jpg"><img class="alignnone  wp-image-7766" src="http://cdn.alloyteam.com/wp-content/uploads/2015/06/31.jpg" alt="3" width="523" height="447" /></a></p>
<p>双击APMServ.exe启动应用，可以看到下面的界面：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/06/4.jpg"><img class="alignnone  wp-image-7767" src="http://cdn.alloyteam.com/wp-content/uploads/2015/06/4.jpg" alt="4" width="516" height="385" /></a><br />
因为我们只需要一个静态服务器，所以把MySQL和SSL等选项都去掉，然后点击“启动APMServ”就完成我们的静态服务器了。这时要部署应用，只需要把文件放到apmServer/www/htdocs目录下面就可以访问到了。这里想说的是其虚拟目录配置，即映射硬盘上任一目录作为服务器的一个子目录。有了虚拟目录，我们就可以定制出多个不同的服务器了。</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/06/12.jpg"><img class="alignnone  wp-image-7778" src="http://cdn.alloyteam.com/wp-content/uploads/2015/06/12.jpg" alt="12" width="512" height="317" /></a></p>
<p>打开虚拟目录的配置界面，填写虚拟目录名称（英文），中文备注，选择网页根目录，然后保存虚拟目录，重启ApmServer后,就可以访问我们的虚拟目录了。</p>
<p><span style="text-decoration: underline;">优点：简单，快速，集成PHP开发环境（PHP，MySQL等）,支持虚拟目录等许多实用功能</span><br />
<span style="text-decoration: underline;">缺点：用着用着就启动不了</span></p>
<p><strong>三：使用Tomcat</strong><br />
Tomcat是Java应用服务器，当然也可以用来作静态服务器。但Tomcat默认的一些配置不太友好，所以我们要定制一些配置。首先就是让Tomcat支持显示目录文件。打开Tomcat/conf/web.xml，修改listings为true。</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/06/91.png"><img class="alignnone  wp-image-7774" src="http://cdn.alloyteam.com/wp-content/uploads/2015/06/91.png" alt="9" width="781" height="290" /></a></p>
<p>Tomcat中虚拟目录配置是位于Tomcat/conf/server.xml。在在host标签中增加如下格式的配置：</p><pre class="crayon-plain-tag">&lt;Context path="虚拟目录名" docBase="文件所在根目录" crossContext="true" /&gt;</pre><p>如：&lt;Context path=&#8221;/test&#8221; docBase=&#8221;G:/Test&#8221; crossContext=&#8221;true&#8221; /&gt;</p>
<p>完成上面配置后，双击Tomcat/bin/startup.bat即可以启动Tomcate服务器，在浏览器中就可以正常访问到刚我们配好的目录了。</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2015/06/101.png"><img class="alignnone  wp-image-7775" src="http://cdn.alloyteam.com/wp-content/uploads/2015/06/101.png" alt="10" width="598" height="434" /></a></p>
<p>优点：功能强大<br />
缺点：配置复杂</p>
<p><strong>小结：</strong><br />
如果没有特别要求，使用http-server基本就能满足我们前端对服务器的要求了</p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/06/kuai-su-da-jian-jing-tai-fu-wu-qi-di-ji-zhong-fang-fa/feed/</wfw:commentRss>
		<slash:comments>9</slash:comments>
		</item>
		<item>
		<title>深入浅出directive</title>
		<link>http://www.alloyteam.com/2015/06/shen-ru-qian-chu-directive/</link>
		<comments>http://www.alloyteam.com/2015/06/shen-ru-qian-chu-directive/#comments</comments>
		<pubDate>Tue, 30 Jun 2015 15:25:11 +0000</pubDate>
		<dc:creator><![CDATA[TAT.mandyluo]]></dc:creator>
				<category><![CDATA[Web开发]]></category>

		<guid isPermaLink="false">http://www.alloyteam.com/?p=7777</guid>
		<description><![CDATA[在 Angular, Vue.js等MVVM框架中，都涉及到指令（directive）的概念，directiv [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>在 Angular, Vue.js等MVVM框架中，都涉及到指令（directive）的概念，directive实际上是一种针对DOM操作的抽象封装，并通过框架处理，将DOM操作逻辑与DOM元素进行自动化绑定，用一个简单的声明式语法简化了DOM操作逻辑中的“<em>给元素命名”</em>，“<em>查询目标元素</em>”，“<em>进行DOM操作”</em>步骤。<br />
<span id="more-7777"></span><br />
举个小例子，比如我们有一个header组件，它的HTML片段内容是：<br />
<code></code></p><pre class="crayon-plain-tag">&lt;div class="header"&gt;
 &lt;button&gt;按钮&lt;/button&gt;
&lt;/div&gt;</pre><p>&nbsp;</p>
<p>如果我们希望给这里的按钮添加一个高亮的class，用zepto的代码是这样写的：</p><pre class="crayon-plain-tag">var $ = require('zepto');
var $btn = $('.header button')
$btn.addClass('highlight')</pre><p>由以上小例子可以看出，我们在写JS交互逻辑的时候，几乎所有的JS交互逻辑都像以下流程一样：</p><pre class="crayon-plain-tag">初始化／数据变更／事件触发 --&gt; 给目标元素命名（或者使用DOM树结构）--&gt; 用选择器选中目标元素 --&gt; 进行DOM操作</pre><p>为此，封装DOM操作并自动化将DOM操作与元素绑定，可以减少1/2的交互逻辑代码（1个步骤替换3步骤），甚至做到根据DOM操作与元素与及数据进行绑定，那就可以用一个绑定声明减少了全部的手动步骤。</p>
<p>根据这一思路，我们先实现DOM操作封装与与元素绑定<br />
我们使用“binding-class”作为动态添加class的绑定声明：</p><pre class="crayon-plain-tag">&lt;div class="header"&gt;
    &lt;button binding-class="highlight:isOn"&gt;按钮&lt;/button&gt;
&lt;/div&gt;</pre><p>实现该绑定声明：</p><pre class="crayon-plain-tag">// 绑定时依赖的数据
var data = {
    isOn: true
}
// 封装DOM操作
function addClassOrRemove (el, clazz, cnd) {
    var $el = $(el)
    cnd ? $el.addClass(clazz) : $el.removeClass(clazz)
}
// 将DOM操作与元素绑定，返回操作步骤
function classBinding () {
    var tar = document.querySelector('[binding-class]')
    var dec = $(tar).attr('binding-class')
    var clazz = desc.split(':')[0]
    var field = desc.split(':')[1].trim()
    return function () {
        addClassOrRemove(tar, clazz, data[field])
    }
}
// 进行绑定操作，获取绑定后的操作方法
var updateClassAction = classBinding()
// 初始化时更新
updateClassAction()</pre><p>&nbsp;</p>
<p>显然，在完成DOM操作与DOM元素的绑定后，以后的每次更新触发场景中一个步骤就可以完成DOM元素的更新。<br />
我们需要更懒惰一点，把手动触发更新的操作也省略了，如何？<br />
那么我们需要现实监听数据的变更，在不考虑兼容IE9以下浏览器的情况下，我们可以使用ES5的<code>defineProperty</code>方法来实现：</p><pre class="crayon-plain-tag">var data = {}
var _isOn
Object.defineProperty(data, 'isOn', {
    get: function () {
        return _isOn
    },
    set: function (nextValue) {
        _isOn = nextValue
        // 在监听到数据变更后立即触发UI更新
        updateClassAction()
    }
})</pre><p>&nbsp;</p>
<p>这就是MVVM的数据绑定的实现，在框架帮助下完成以上一系列的绑定行为，要完成根据状态给按钮添加／移除高亮的class，我们只需要这样一个属性标志：<br />
<code></code></p><pre class="crayon-plain-tag">&lt;div class="header"&gt;
    &lt;button binding-class="highlight: isOn"&gt;按钮&lt;/button&gt;
&lt;/div&gt;</pre><p>&nbsp;</p>
<p>个人认为，使用属性声明的方式自动化绑定优于具名选择器的方式操作DOM元素。从开发效率角度，我们省去了“<em>给元素命名”</em>／“<em>查询目标元素</em>”／“<em>进行DOM操作</em>”这3步操作，从维护性角度，我们也省却了“<em>知道文档结构”</em>／“<em>知道选择器标志</em>”2个步骤。</p>
]]></content:encoded>
			<wfw:commentRss>http://www.alloyteam.com/2015/06/shen-ru-qian-chu-directive/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
	</channel>
</rss>

<!-- Dynamic page generated in 1.561 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2015-09-22 17:49:10 -->
